#!/usr/bin/env python3
"""
Google Classroom Assignment Solver
==================================================

This CLI tool connects to the Google Classroom and Drive APIs to:
1. Detect new programming assignments.
2. Extract the text content and requirements.
3. Use Gemini API to generate solutions in Python/Java/C++.
4. Execute the code and capture output screenshots.
5. Upload solution documents to Google Drive.

Setup:
-------
1. Enable Google Classroom & Drive APIs in Google Cloud Console.
2. Download OAuth credentials.json.
3. Install dependencies:
   pip install google-auth google-auth-oauthlib google-api-python-client \
               google-generativeai python-dotenv typer rich pdfplumber pillow
4. Create a .env file with:
   GEMINI_API_KEY=your_api_key_here
5. Run for the first time to authenticate:
   python assignment_solver.py list-courses
6. Run to detect new assignments:
   python assignment_solver.py solve --all-courses --since 24
"""

import os
import pickle
import re
import io
import subprocess
import tempfile
from datetime import datetime, timedelta, timezone
from typing import List, Dict, Tuple, Optional
import typer
from rich import print
from rich.console import Console
from rich.panel import Panel
from rich.status import Status
from PIL import Image, ImageDraw, ImageFont
import base64

# Google API Imports
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaIoBaseDownload, MediaIoBaseUpload

# Text & AI Imports
import google.generativeai as genai
from dotenv import load_dotenv
import pdfplumber

# ---------------------- Setup ----------------------
app = typer.Typer(help="A CLI Assignment Solver for Google Classroom, powered by Gemini AI.")
console = Console()
load_dotenv()

SCOPES = [
    'https://www.googleapis.com/auth/classroom.courses.readonly',
    'https://www.googleapis.com/auth/classroom.coursework.me.readonly',
    'https://www.googleapis.com/auth/classroom.courseworkmaterials.readonly',
    'https://www.googleapis.com/auth/drive.readonly',
    'https://www.googleapis.com/auth/drive.file',
    'https://www.googleapis.com/auth/documents'
]

# ---------------------- Core Class ----------------------
class AssignmentSolverCLI:
    def __init__(self, credentials_file='credentials.json', token_file='token.pickle'):
        self.credentials_file = credentials_file
        self.token_file = token_file
        self.creds = None
        self.classroom_service = None
        self.drive_service = None
        self.docs_service = None
        self.gemini_model = None
        self._authenticate()
        self._setup_gemini()

    def _authenticate(self):
        """Authenticate with Google APIs (Classroom, Drive & Docs)."""
        creds = None
        if os.path.exists(self.token_file):
            with open(self.token_file, 'rb') as token:
                creds = pickle.load(token)

        if not creds or not creds.valid:
            if creds and creds.expired and creds.refresh_token:
                console.print("[yellow]Refreshing expired credentials...[/yellow]")
                try:
                    creds.refresh(Request())
                except Exception as e:
                    console.print(f"[red]Error refreshing token: {e}[/red]")
                    console.print("[yellow]Please re-authenticate.[/yellow]")
                    creds = None
                    if os.path.exists(self.token_file):
                         os.remove(self.token_file)
            
            if not creds:
                if not os.path.exists(self.credentials_file):
                    raise FileNotFoundError(
                        f"Credentials file '{self.credentials_file}' not found. "
                        "Download it from Google Cloud Console."
                    )
                console.print("[cyan]Authenticating with Google...[/cyan]")
                flow = InstalledAppFlow.from_client_secrets_file(self.credentials_file, SCOPES)
                creds = flow.run_local_server(port=0)

            with open(self.token_file, 'wb') as token:
                pickle.dump(creds, token)
            console.print("[green]âœ“ Authentication successful![/green]")

        self.creds = creds
        try:
            self.classroom_service = build('classroom', 'v1', credentials=creds)
            self.drive_service = build('drive', 'v3', credentials=creds)
            self.docs_service = build('docs', 'v1', credentials=creds)
            console.print("[green]âœ“ Classroom, Drive, and Docs services initialized.[/green]")
        except HttpError as e:
            console.print(f"[red]Error building services: {e}[/red]")
            raise

    def _setup_gemini(self):
        """Setup Gemini AI."""
        api_key = os.getenv('GEMINI_API_KEY')
        if not api_key:
            raise ValueError("Missing GEMINI_API_KEY in environment variables (.env file).")
        genai.configure(api_key=api_key)
        self.gemini_model = genai.GenerativeModel('models/gemini-1.5-flash')
        console.print("[green]âœ“ Gemini AI configured![/green]")

    def get_courses(self):
        """Fetch available Google Classroom courses."""
        try:
            results = self.classroom_service.courses().list(
                pageSize=100, courseStates=['ACTIVE']
            ).execute()
            return results.get('courses', [])
        except HttpError as e:
            console.print(f"[red]âš ï¸ Error fetching courses:[/red] {e}")
            return []

    def get_new_assignments(self, course_id, since_hours):
        """Fetch new courseWork (assignments) from a course."""
        try:
            cutoff_time = datetime.now(timezone.utc) - timedelta(hours=since_hours)
            
            assignments = []
            page_token = None
            while True:
                response = self.classroom_service.courses().courseWork().list(
                    courseId=course_id,
                    pageSize=20,
                    pageToken=page_token,
                    orderBy='updateTime desc'
                ).execute()
                
                items = response.get('courseWork', [])
                
                for item in items:
                    update_time = self._parse_timestamp(item.get('updateTime'))
                    if update_time > cutoff_time:
                        assignments.append(item)
                    else:
                        return assignments
                
                page_token = response.get('nextPageToken')
                if not page_token or not items:
                    break
                    
            return assignments
        except HttpError as e:
            console.print(f"[red]âš ï¸ Error fetching assignments for course {course_id}:[/red] {e}")
            return []

    def _parse_timestamp(self, ts: str):
        """Parses Google API timestamp to a comparable datetime object."""
        if not ts:
            return datetime.min.replace(tzinfo=timezone.utc)
        if '.' in ts:
            ts = ts.split('.')[0] + 'Z'
        return datetime.strptime(ts, '%Y-%m-%dT%H:%M:%SZ').replace(tzinfo=timezone.utc)

    def get_drive_file_text(self, drive_file) -> Optional[str]:
        """Downloads a Google Drive file and extracts text."""
        file_id = drive_file.get('id')
        name = drive_file.get('title', 'Unknown File')
        
        try:
            metadata = self.drive_service.files().get(fileId=file_id, fields='mimeType, name').execute()
            mime_type = metadata.get('mimeType')
            name = metadata.get('name', name)
            
            console.print(f"  > Reading file: [dim]{name}[/dim] (Type: {mime_type})")
            
            request = None
            if 'google-apps.document' in mime_type:
                request = self.drive_service.files().export_media(
                    fileId=file_id, mimeType='text/plain'
                )
            elif 'google-apps.presentation' in mime_type:
                request = self.drive_service.files().export_media(
                    fileId=file_id, mimeType='text/plain'
                )
            elif 'pdf' in mime_type:
                request = self.drive_service.files().get_media(fileId=file_id)
            else:
                console.print(f"  [yellow]Skipping unsupported file type: {mime_type}[/yellow]")
                return None

            fh = io.BytesIO()
            downloader = MediaIoBaseDownload(fh, request)
            done = False
            while not done:
                status, done = downloader.next_chunk()
            
            fh.seek(0)
            
            if 'pdf' in mime_type:
                try:
                    with pdfplumber.open(fh) as pdf:
                        full_text = "\n".join(
                            page.extract_text() for page in pdf.pages if page.extract_text()
                        )
                        return full_text
                except Exception as e:
                    console.print(f"  [red]Error reading PDF content: {e}[/red]")
                    return None
            else:
                return fh.read().decode('utf-8')

        except HttpError as e:
            console.print(f"  [red]Error accessing Drive file {name}: {e}[/red]")
            return None

    def detect_language(self, assignment_text: str) -> str:
        """Use Gemini to detect the programming language required."""
        prompt = f"""
        Analyze this assignment text and determine which programming language is required.
        Only respond with ONE word: "python", "java", or "cpp" (for C++).
        If unclear, default to "python".
        
        Assignment text:
        {assignment_text}
        """
        try:
            response = self.gemini_model.generate_content(prompt)
            lang = response.text.strip().lower()
            if lang in ['python', 'java', 'cpp']:
                return lang
            return 'python'
        except:
            return 'python'

    def generate_solution(self, assignment_text: str, language: str) -> Dict[str, str]:
        """Generate code solution using Gemini."""
        prompt = f"""
        You are an expert programming tutor. Given this assignment, generate a complete solution in {language.upper()}.
        
        Assignment:
        {assignment_text}
        
        Provide your response in the following EXACT format:
        
        SOLUTION_CODE:
        ```{language}
        [Your complete, executable code here]
        ```
        
        EXPLANATION:
        [Brief explanation of your approach and key concepts]
        
        Requirements:
        - The code must be complete and executable
        - Include all necessary imports/includes
        - Add comments explaining key sections
        - For Python: use proper main guard if needed
        - For Java: include proper class structure with main method
        - For C++: include all headers and use proper namespace
        - Handle edge cases and input validation
        """
        
        try:
            response = self.gemini_model.generate_content(prompt)
            text = response.text
            
            # Extract code
            code_match = re.search(r'```(?:' + language + r')?\n(.*?)\n```', text, re.DOTALL)
            code = code_match.group(1).strip() if code_match else ""
            
            # Extract explanation
            explanation_match = re.search(r'EXPLANATION:\s*(.*?)(?:\n\n|$)', text, re.DOTALL)
            explanation = explanation_match.group(1).strip() if explanation_match else "Solution generated."
            
            return {
                'code': code,
                'explanation': explanation,
                'language': language
            }
        except Exception as e:
            console.print(f"[red]Error generating solution: {e}[/red]")
            return {
                'code': f"# Error generating solution: {e}",
                'explanation': "Failed to generate solution.",
                'language': language
            }

    def execute_code(self, code: str, language: str) -> Tuple[str, bool]:
        """Execute code and return output."""
        with tempfile.TemporaryDirectory() as tmpdir:
            try:
                if language == 'python':
                    file_path = os.path.join(tmpdir, 'solution.py')
                    with open(file_path, 'w') as f:
                        f.write(code)
                    
                    result = subprocess.run(
                        ['python3', file_path],
                        capture_output=True,
                        text=True,
                        timeout=10
                    )
                    
                elif language == 'java':
                    # Extract class name
                    class_match = re.search(r'public\s+class\s+(\w+)', code)
                    class_name = class_match.group(1) if class_match else 'Solution'
                    
                    file_path = os.path.join(tmpdir, f'{class_name}.java')
                    with open(file_path, 'w') as f:
                        f.write(code)
                    
                    # Compile
                    compile_result = subprocess.run(
                        ['javac', file_path],
                        capture_output=True,
                        text=True,
                        timeout=10
                    )
                    
                    if compile_result.returncode != 0:
                        return f"Compilation Error:\n{compile_result.stderr}", False
                    
                    # Run
                    result = subprocess.run(
                        ['java', '-cp', tmpdir, class_name],
                        capture_output=True,
                        text=True,
                        timeout=10
                    )
                    
                elif language == 'cpp':
                    file_path = os.path.join(tmpdir, 'solution.cpp')
                    exe_path = os.path.join(tmpdir, 'solution')
                    
                    with open(file_path, 'w') as f:
                        f.write(code)
                    
                    # Compile
                    compile_result = subprocess.run(
                        ['g++', file_path, '-o', exe_path],
                        capture_output=True,
                        text=True,
                        timeout=10
                    )
                    
                    if compile_result.returncode != 0:
                        return f"Compilation Error:\n{compile_result.stderr}", False
                    
                    # Run
                    result = subprocess.run(
                        [exe_path],
                        capture_output=True,
                        text=True,
                        timeout=10
                    )
                
                output = result.stdout if result.stdout else result.stderr
                success = result.returncode == 0
                
                return output, success
                
            except subprocess.TimeoutExpired:
                return "Execution timed out (10 seconds limit)", False
            except Exception as e:
                return f"Execution error: {str(e)}", False

    def create_output_screenshot(self, output_text: str, language: str) -> io.BytesIO:
        """Create a screenshot image of the output."""
        # Create image with output text
        img_width = 800
        font_size = 14
        padding = 20
        
        try:
            font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSansMono.ttf", font_size)
        except:
            font = ImageFont.load_default()
        
        # Calculate required height
        lines = output_text.split('\n')
        line_height = font_size + 4
        img_height = max(200, len(lines) * line_height + padding * 2)
        
        # Create image
        img = Image.new('RGB', (img_width, img_height), color='#1e1e1e')
        draw = ImageDraw.Draw(img)
        
        # Draw title
        title = f"Output ({language.upper()}):"
        draw.text((padding, padding), title, fill='#00ff00', font=font)
        
        # Draw output
        y_position = padding + line_height + 10
        for line in lines[:50]:  # Limit to 50 lines
            draw.text((padding, y_position), line[:100], fill='#ffffff', font=font)
            y_position += line_height
        
        # Save to BytesIO
        img_io = io.BytesIO()
        img.save(img_io, format='PNG')
        img_io.seek(0)
        
        return img_io

    def upload_image_to_drive(self, image_io: io.BytesIO, filename: str) -> Optional[str]:
        """Upload image to Drive and return its ID."""
        file_metadata = {'name': filename}
        image_io.seek(0)
        media = MediaIoBaseUpload(
            image_io,
            mimetype='image/png',
            resumable=True
        )
        try:
            file = self.drive_service.files().create(
                body=file_metadata,
                media_body=media,
                fields='id'
            ).execute()
            
            # Make it publicly readable
            self.drive_service.permissions().create(
                fileId=file['id'],
                body={'type': 'anyone', 'role': 'reader'}
            ).execute()
            
            return file['id']
        except HttpError as e:
            console.print(f"[red]Error uploading image: {e}[/red]")
            return None

    def create_solution_doc(self, assignment_title: str, assignment_text: str, 
                           solution: Dict, output: str, screenshot_id: str) -> Optional[str]:
        """Create a Google Doc with the solution."""
        doc_title = f"Solution_{re.sub(r'[^\w\-_\. ]', '', assignment_title).replace(' ', '_')}"
        
        try:
            # Create document
            doc = self.docs_service.documents().create(body={'title': doc_title}).execute()
            doc_id = doc['documentId']
            
            # Prepare content
            requests = [
                # Title
                {
                    'insertText': {
                        'location': {'index': 1},
                        'text': f'{assignment_title}\nSolution Document\n\n'
                    }
                },
                # Question section
                {
                    'insertText': {
                        'location': {'index': 1},
                        'text': f'QUESTION:\n{assignment_text}\n\n'
                    }
                },
                # Explanation
                {
                    'insertText': {
                        'location': {'index': 1},
                        'text': f'EXPLANATION:\n{solution["explanation"]}\n\n'
                    }
                },
                # Solution code
                {
                    'insertText': {
                        'location': {'index': 1},
                        'text': f'SOLUTION CODE ({solution["language"].upper()}):\n\n{solution["code"]}\n\n'
                    }
                },
                # Output section
                {
                    'insertText': {
                        'location': {'index': 1},
                        'text': f'EXPECTED OUTPUT:\n{output}\n\n'
                    }
                },
                # Screenshot header
                {
                    'insertText': {
                        'location': {'index': 1},
                        'text': 'OUTPUT SCREENSHOT:\n'
                    }
                }
            ]
            
            # Execute text insertions (in reverse order due to index 1)
            for req in reversed(requests):
                self.docs_service.documents().batchUpdate(
                    documentId=doc_id,
                    body={'requests': [req]}
                ).execute()
            
            # Insert screenshot if available
            if screenshot_id:
                # Get document to find end index
                doc = self.docs_service.documents().get(documentId=doc_id).execute()
                end_index = doc['body']['content'][-1]['endIndex']
                
                self.docs_service.documents().batchUpdate(
                    documentId=doc_id,
                    body={'requests': [{
                        'insertInlineImage': {
                            'location': {'index': end_index - 1},
                            'uri': f'https://drive.google.com/uc?id={screenshot_id}',
                            'objectSize': {
                                'height': {'magnitude': 400, 'unit': 'PT'},
                                'width': {'magnitude': 600, 'unit': 'PT'}
                            }
                        }
                    }]}
                ).execute()
            
            doc_url = f"https://docs.google.com/document/d/{doc_id}/edit"
            console.print(f"  [green]âœ“ Solution document created![/green] [dim]({doc_url})[/dim]")
            return doc_url
            
        except HttpError as e:
            console.print(f"[red]Error creating document: {e}[/red]")
            return None


# ---------------------- Typer Commands ----------------------

@app.command()
def list_courses(
    credentials: str = typer.Option("credentials.json", help="Path to credentials file."),
    token: str = typer.Option("token.pickle", help="Path to saved token file."),
):
    """List all your active Google Classroom courses."""
    console.print("ðŸ“š [bold]Fetching your courses...[/bold]\n")
    cli = AssignmentSolverCLI(credentials_file=credentials, token_file=token)
    courses = cli.get_courses()
    if not courses:
        console.print("No active courses found.")
        raise typer.Exit()
    
    console.print(Panel(
        "\n".join([f"â€¢ [green]{c['name']}[/green] (ID: {c['id']})" for c in courses]),
        title="Active Courses",
        border_style="blue"
    ))

@app.command()
def solve(
    course_id: str = typer.Option(None, help="Specific course ID to scan."),
    all_courses: bool = typer.Option(False, "--all-courses", help="Scan all available courses."),
    since: int = typer.Option(24, help="Only scan assignments from last N hours."),
    credentials: str = typer.Option("credentials.json", help="Path to credentials file"),
    token: str = typer.Option("token.pickle", help="Path to saved token file."),
    auto_language: bool = typer.Option(True, help="Auto-detect programming language"),
    force_language: str = typer.Option(None, help="Force a specific language (python/java/cpp)")
):
    """
    Detect new assignments and generate solutions with screenshots.
    """
    console.print("ðŸš€ [bold]Initializing Assignment Solver...[/bold]")
    cli = AssignmentSolverCLI(credentials_file=credentials, token_file=token)
    print()

    # Determine which courses to process
    if course_id:
        try:
            course_info = cli.classroom_service.courses().get(id=course_id).execute()
            course_name = course_info.get('name', f'Course {course_id}')
            courses = [{'id': course_id, 'name': course_name}]
        except HttpError:
            console.print(f"[red]Error: Could not find course with ID {course_id}[/red]")
            raise typer.Exit()
    elif all_courses:
        courses = cli.get_courses()
        if not courses:
            console.print("[red]No active courses found.[/red]")
            raise typer.Exit()
    else:
        console.print("[yellow]â— Please specify either --course-id or --all-courses.[/yellow]")
        raise typer.Exit()

    # Main Processing Loop
    total_assignments_found = 0
    for course in courses:
        course_name = course['name']
        console.rule(f"[bold blue]ðŸ” Scanning: {course_name}[/bold blue]")
        
        new_assignments = cli.get_new_assignments(course['id'], since_hours=since)
        
        if not new_assignments:
            console.print(f"[dim]No new assignments found in the last {since} hours.[/dim]\n")
            continue
            
        console.print(f"ðŸ“¢ Found [green]{len(new_assignments)}[/green] new assignment(s)!")
        total_assignments_found += len(new_assignments)
        
        for assignment in new_assignments:
            title = assignment.get('title', 'Untitled Assignment')
            description = assignment.get('description', '')
            console.print(f"\n[bold]Processing Assignment:[/bold] [cyan]{title}[/cyan]")
            
            # Extract full assignment text
            assignment_text = f"Title: {title}\n\n{description}"
            
            # Check for attached materials
            if assignment.get('materials'):
                for item in assignment.get('materials', []):
                    drive_file = item.get('driveFile', {}).get('driveFile')
                    if drive_file:
                        text = cli.get_drive_file_text(drive_file)
                        if text:
                            assignment_text += f"\n\n--- Attachment: {drive_file.get('title', 'N/A')} ---\n{text}"
            
            console.print(f"[green]  âœ“ Extracted assignment details.[/green]")
            
            # Ask for confirmation
            if not typer.confirm(f"\nðŸ§  Generate solution for '{title}'?"):
                console.print("[dim]  > Skipping.[/dim]")
                continue
            
            # Detect or use forced language
            if force_language and force_language in ['python', 'java', 'cpp']:
                language = force_language
            else:
                with Status("[bold magenta]Detecting programming language...[/bold magenta]", console=console):
                    language = cli.detect_language(assignment_text)
            
            console.print(f"  [cyan]Language detected: {language.upper()}[/cyan]")
            
            # Generate solution
            with Status("[bold magenta]Generating solution code...[/bold magenta]", console=console):
                solution = cli.generate_solution(assignment_text, language)
            
            console.print(f"  [green]âœ“ Solution generated![/green]")
            
            # Execute code
            with Status("[bold magenta]Executing code...[/bold magenta]", console=console):
                output, success = cli.execute_code(solution['code'], language)
            
            if success:
                console.print(f"  [green]âœ“ Code executed successfully![/green]")
            else:
                console.print(f"  [yellow]âš  Code execution had issues[/yellow]")
            
            console.print(f"\n[dim]Output preview:[/dim]\n{output[:200]}{'...' if len(output) > 200 else ''}\n")
            
            # Create screenshot
            with Status("[bold magenta]Creating output screenshot...[/bold magenta]", console=console):
                screenshot_io = cli.create_output_screenshot(output, language)
                screenshot_id = cli.upload_image_to_drive(
                    screenshot_io,
                    f"output_screenshot_{re.sub(r'[^\w]', '', title)}.png"
                )
            
            if screenshot_id:
                console.print(f"  [green]âœ“ Screenshot created and uploaded![/green]")
            
            # Create solution document
            with Status("[bold magenta]Creating solution document...[/bold magenta]", console=console):
                doc_url = cli.create_solution_doc(
                    title,
                    assignment_text,
                    solution,
                    output,
                    screenshot_id
                )
            
            console.print(f"\n[bold green]âœ… Done processing '{title}'![/bold green]")
            
    console.rule("[bold]Processing Complete[/bold]")
    console.print(f"âœ… Scanned [bold]{len(courses)}[/bold] course(s).")
    console.print(f"ðŸŽ¯ Found [bold]{total_assignments_found}[/bold] new assignments.")
    console.print()


# ---------------------- Main ----------------------
if __name__ == "__main__":
    app()
