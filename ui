#!/usr/bin/env python3
"""
Google Classroom Announcement Monitor & Analyzer
==================================================

This CLI connects to the Google Classroom API to retrieve, summarize,
and analyze announcements.

Features:
----------
‚Ä¢ OAuth2 authentication with Google Classroom.
‚Ä¢ 'summarize' command: Provides a single AI summary for all recent announcements in a course.
‚Ä¢ 'detect' command: Scans announcements for keywords (project, lab test) and generates
  tailored project ideas or practice questions for *each* matching announcement.
‚Ä¢ 'analyze' command: Manually analyze any piece of text for project/lab test content.
‚Ä¢ 'list-courses' command: Lists all your active courses.

Setup:
-------
1. Enable Google Classroom & Drive APIs in Google Cloud Console.
2. Download OAuth credentials.json.
3. Install dependencies:
   pip install google-auth google-auth-oauthlib google-api-python-client google-generativeai python-dotenv typer rich
4. Create a .env file with:
   GEMINI_API_KEY=your_api_key_here
5. Run:
   python classroom_monitor.py --help
   python classroom_monitor.py detect --all-courses --since 24
   python classroom_monitor.py summarize --all-courses --since 72
"""

import os
import pickle
import re
from datetime import datetime, timedelta
from typing import List, Dict, Tuple
import typer
from rich import print
from rich.console import Console
from rich.panel import Panel
from rich.markdown import Markdown
from rich.table import Table
from rich.text import Text

from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

import google.generativeai as genai
from dotenv import load_dotenv

# ---------------------- Setup ----------------------
# Merged help text
app = typer.Typer(help="Monitor, summarize, and analyze Google Classroom announcements with Gemini AI.")
console = Console()
load_dotenv()

SCOPES = [
    'https://www.googleapis.com/auth/classroom.courses.readonly',
    'https://www.googleapis.com/auth/classroom.announcements.readonly'
]

# Project-related keywords to detect
PROJECT_KEYWORDS = [
    'synopsis', 'project', 'pbl', 'problem-based learning', 'problem based learning',
    'assignment', 'capstone', 'thesis', 'research', 'presentation', 'proposal',
    'implementation', 'development', 'design', 'prototype', 'deliverable',
    'milestone', 'case study', 'report', 'documentation', 'mini project',
    'major project', 'final year project', 'term project', 'semester project'
]

# Lab test/evaluation keywords to detect
LAB_TEST_KEYWORDS = [
    'lab test', 'evaluation', 'practical exam', 'viva', 'quiz',
    'midterm', 'final exam', 'coding test', 'assessment', 'lab evaluation'
]


# ---------------------- Core Class ----------------------
class ClassroomMonitor:
    # --- MODIFIED ---
    def __init__(self, console: Console, credentials_file='credentials.json', token_file='token.pickle'):
        self.credentials_file = credentials_file
        self.token_file = token_file
        self.service = None
        self.gemini_model = None
        self.console = console  # <-- Inject console for status updates
        self._authenticate()
        self._setup_gemini()

    def _authenticate(self):
        """Authenticate with Google Classroom API."""
        creds = None
        if os.path.exists(self.token_file):
            with open(self.token_file, 'rb') as token:
                creds = pickle.load(token)

        if not creds or not creds.valid:
            if creds and creds.expired and creds.refresh_token:
                # --- MODIFIED ---
                with self.console.status("[yellow]Refreshing expired credentials...[/yellow]", spinner="dots"):
                    creds.refresh(Request())
            else:
                if not os.path.exists(self.credentials_file):
                    raise FileNotFoundError(
                        f"Credentials file '{self.credentials_file}' not found. "
                        "Download it from Google Cloud Console and name it 'credentials.json'."
                    )
                # --- MODIFIED ---
                with self.console.status("[cyan]Authenticating with Google... (check browser)[/cyan]", spinner="earth"):
                    flow = InstalledAppFlow.from_client_secrets_file(self.credentials_file, SCOPES)
                    creds = flow.run_local_server(port=0)

            with open(self.token_file, 'wb') as token:
                pickle.dump(creds, token)
            self.console.print("[green]‚úì Authentication successful![/green]")

        self.service = build('classroom', 'v1', credentials=creds)

    def _setup_gemini(self):
        """Setup Gemini AI."""
        api_key = os.getenv('GEMINI_API_KEY')
        if not api_key:
            raise ValueError("Missing GEMINI_API_KEY in environment variables (.env file).")
        genai.configure(api_key=api_key)
        self.gemini_model = genai.GenerativeModel('models/gemini-1.5-flash')
        self.console.print("[green]‚úì Gemini AI configured![/green]")

    def get_courses(self):
        """Fetch available Google Classroom courses."""
        # --- MODIFIED ---
        with self.console.status("üìö [bold]Fetching your courses...[/bold]", spinner="dots"):
            try:
                results = self.service.courses().list(pageSize=100, courseStates=['ACTIVE']).execute()
                return results.get('courses', [])
            except HttpError as e:
                self.console.print(f"[red]‚ö†Ô∏è Error fetching courses:[/red] {e}")
                return []

    def get_announcements(self, course_id, max_results=10, since_hours=None):
        """Retrieve course announcements."""
        # --- MODIFIED ---
        with self.console.status(f"üì¢ [dim]Fetching announcements for course {course_id}...[/dim]", spinner="dots"):
            try:
                announcements, page_token = [], None
                while True:
                    response = self.service.courses().announcements().list(
                        courseId=course_id,
                        pageSize=min(max_results, 100),
                        pageToken=page_token,
                        orderBy='updateTime desc'
                    ).execute()

                    items = response.get('announcements', [])
                    
                    if since_hours:
                        cutoff_time = datetime.utcnow() - timedelta(hours=since_hours)
                        cutoff_time = cutoff_time.replace(tzinfo=None) 
                        
                        filtered_items = []
                        for i in items:
                            update_time = self._parse_timestamp(i.get('updateTime'))
                            if update_time > cutoff_time:
                                filtered_items.append(i)
                            else:
                                break 
                        items = filtered_items

                    announcements.extend(items)
                    page_token = response.get('nextPageToken')
                    
                    if not page_token or len(announcements) >= max_results or (since_hours and not items):
                        break

                return announcements[:max_results]
            except HttpError as e:
                self.console.print(f"[red]‚ö†Ô∏è Error fetching announcements:[/red] {e}")
                return []

    def _parse_timestamp(self, ts: str):
        """Using the more robust parser from the detector script."""
        if not ts:
            return datetime.min
        ts = ts.split('.')[0] # Remove fractional seconds
        ts = ts.replace('Z', '')
        try:
            return datetime.fromisoformat(ts)
        except Exception:
            try:
                return datetime.strptime(ts, "%Y-m-%dT%H:%M:%S")
            except Exception:
                return datetime.min

    # --- Method from Summarizer Script ---
    def summarize_course_announcements(self, course_name, announcements):
        """Summarize all announcements in a single Gemini summary."""
        if not announcements:
            return "No recent announcements to summarize."

        compiled_texts = []
        for ann in announcements:
            timestamp = self._parse_timestamp(ann.get('updateTime', '')).strftime("%Y-%m-%d %H:%M")
            text = ann.get('text', '').strip() or 'No content.'
            compiled_texts.append(f"[{timestamp}] {text}")

        prompt = f"""
You are a helpful assistant summarizing all recent announcements for a course.
Course: {course_name}
Announcements:
{chr(10).join(compiled_texts)}
Provide a concise, student-friendly summary including:
- Main topics or updates
- Deadlines or key info
- Context or instructions
Do not bold the text.
"""
        # --- MODIFIED ---
        with self.console.status("\nü§ñ [cyan]Generating overall course summary...[/cyan]", spinner="line"):
            try:
                response = self.gemini_model.generate_content(prompt)
                return response.text.strip()
            except Exception as e:
                return f"‚ö†Ô∏è Error generating summary: {str(e)}"

    # --- Methods from Detector Script ---
    def detect_project_announcements(self, announcements: List[Dict]) -> List[Tuple[Dict, List[str]]]:
        """
        Detect announcements containing project-related keywords.
        """
        project_announcements = []
        for ann in announcements:
            text = ann.get('text', '').lower()
            matched_keywords = []
            for keyword in PROJECT_KEYWORDS:
                if re.search(r'\b' + re.escape(keyword) + r'\b', text, re.IGNORECASE):
                    matched_keywords.append(keyword)
            if matched_keywords:
                project_announcements.append((ann, list(set(matched_keywords))))
        return project_announcements

    def detect_lab_test_announcements(self, announcements: List[Dict]) -> List[Tuple[Dict, List[str]]]:
        """
        Detect announcements containing lab test/evaluation keywords.
        """
        lab_test_announcements = []
        for ann in announcements:
            text = ann.get('text', '').lower()
            matched_keywords = []
            for keyword in LAB_TEST_KEYWORDS:
                if re.search(r'\b' + re.escape(keyword) + r'\b', text, re.IGNORECASE):
                    matched_keywords.append(keyword)
            if matched_keywords:
                is_project = False
                for proj_keyword in PROJECT_KEYWORDS:
                     if re.search(r'\b' + re.escape(proj_keyword) + r'\b', text, re.IGNORECASE):
                        is_project = True
                        break
                if not is_project:
                    lab_test_announcements.append((ann, list(set(matched_keywords))))
        return lab_test_announcements

    def generate_tailored_project_ideas(self, course_name: str, announcement_text: str, keywords: List[str]) -> str:
        """
        Generate project ideas tailored to the specific announcement requirements.
        """
        prompt = f"""
You are an expert educational advisor analyzing a project announcement and generating tailored project ideas.
Course: {course_name}
Project Announcement (Full Text):
{announcement_text}
Detected Keywords: {', '.join(keywords)}
Your task:
1. CAREFULLY READ and ANALYZE the announcement to understand:
   - Specific requirements and constraints, Topics or domains mentioned, Technologies or tools specified
   - Learning objectives, Deliverables expected, Any deadlines or milestones
   - Team size or collaboration requirements, Evaluation criteria
2. Generate 5-7 TAILORED PROJECT IDEAS that:
   - DIRECTLY match the announcement specifications, Address the stated requirements
   - Are feasible within the given constraints, Align with the course subject and level
   - Incorporate mentioned technologies/tools
3. For EACH project idea provide:
   - **Project Title**: Clear, descriptive name
   - **Description**: 2-3 sentences explaining the project
   - **How it meets requirements**: Explicitly state which announcement requirements it fulfills
   - **Key Technologies/Tools**: Specific tech stack
   - **Implementation Steps**: 4-6 high-level steps
   - **Expected Outcomes**: What students will learn/achieve
   - **Complexity Level**: Beginner/Intermediate/Advanced
4. RESOURCES & REFERENCES:
   - Provide 5-8 specific resources for EACH major technology/tool mentioned
   - Include actual GitHub repository search terms (e.g., "search GitHub for: 'student management system python django'")
   - List relevant tutorial websites with search queries
   - Suggest YouTube channels or specific video searches, Recommend documentation links (provide exact URLs where possible)
   - Mention similar projects on platforms like: GitHub (provide search terms), Kaggle (for data science projects), CodePen/JSFiddle (for web projects)
5. EXAMPLE PROJECT LINKS & SEARCH STRATEGIES:
   - Provide specific GitHub search queries that will find similar completed projects
   - Format: "GitHub Search: [exact search term]"
   - Example: "GitHub Search: 'e-commerce website react node mongodb'"
Format your response clearly with:
- Main headers (##), Subheaders (###), Bullet points for lists, Code blocks for search terms or commands, Bold for emphasis
Be SPECIFIC, PRACTICAL, and ensure all ideas are directly relevant to the announcement content.
"""
        
        # --- MODIFIED ---
        with self.console.status("\nüí° [bold magenta]Generating tailored project ideas...[/bold magenta]", spinner="line"):
            try:
                response = self.gemini_model.generate_content(prompt)
                return response.text.strip()
            except Exception as e:
                return f"‚ö†Ô∏è Error generating project ideas: {str(e)}"

    def generate_practice_questions(self, course_name: str, announcement_text: str, keywords: List[str]) -> str:
        """
        Generate practice lab test questions based on the announcement.
        """
        prompt = f"""
You are an expert Computer Science professor creating a practice test.
Course: {course_name}
Announcement (Full Text):
{announcement_text}
Detected Keywords: {', '.join(keywords)}
Your task:
1. CAREFULLY READ and ANALYZE the announcement to identify:
   - The key topics or concepts to be tested (e.g., "Data Structures," "Algorithms," "Database Queries," "Python Basics").
   - The format of the test (e.g., coding questions, viva, multiple choice).
   - Any specific technologies or languages mentioned.
2. Generate 5-7 TAILORED PRACTICE QUESTIONS that:
   - DIRECTLY relate to the topics in the announcement.
   - Are at an appropriate difficulty level for a university course.
   - Mimic the likely format of the test (focus on coding problems if it's a "lab test").
3. For EACH practice question, provide:
   - **Question Title/Topic**: (e.g., "Array Manipulation," "SQL Join," "Binary Tree Traversal")
   - **Problem Statement**: A clear, concise problem.
   - **Example Input/Output**: (if applicable)
   - **Key Concepts to Apply**: What the student needs to know to solve it.
   - **Hint**: (Optional) A small hint to guide the student.
4. Provide a "Study Guide & Resources" section:
   - List the 3-5 most important topics to review.
   - Provide 5-8 specific resources (documentation links, tutorials, YouTube video searches) to help students prepare for these topics.
   - Format: "Search YouTube for: 'Data Structures in Python full course'"
   - Format: "Read documentation: 'Python 'list' methods'"
Format your response clearly using Markdown (headers, subheaders, bullet points, and code blocks for code).
Be SPECIFIC, PRACTICAL, and ensure all questions are directly relevant to the announcement content.
"""
        
        # --- MODIFIED ---
        with self.console.status("\nüí° [bold cyan]Generating practice questions...[/bold cyan]", spinner="line"):
            try:
                response = self.gemini_model.generate_content(prompt)
                return response.text.strip()
            except Exception as e:
                return f"‚ö†Ô∏è Error generating practice questions: {str(e)}"


# ---------------------- Typer Commands ----------------------

@app.command()
def list_courses(
    credentials: str = typer.Option("credentials.json", help="Path to credentials file"),
    token: str = typer.Option("token.pickle", help="Path to saved token file"),
):
    """List all available Google Classroom courses."""
    # --- MODIFIED ---
    monitor = ClassroomMonitor(console=console, credentials_file=credentials, token_file=token)
    courses = monitor.get_courses()
    
    if not courses:
        console.print("[red]No active courses found.[/red]")
        raise typer.Exit()

    # --- NEW: Use rich.table.Table ---
    table = Table(title="üìö Your Active Google Classroom Courses", border_style="blue")
    table.add_column("Course Name", style="green", no_wrap=True)
    table.add_column("Course ID", style="cyan", no_wrap=True)

    for c in courses:
        table.add_row(c['name'], c['id'])
    
    console.print(table)
    # --- END NEW ---


# --- Command from Summarizer Script ---
@app.command()
def summarize(
    course_id: str = typer.Option(None, help="Specific course ID to summarize."),
    all_courses: bool = typer.Option(False, "--all-courses", help="Summarize all available courses."),
    max_announcements: int = typer.Option(10, "--max", help="Max announcements per course."),
    since: int = typer.Option(None, help="Only include announcements from last N hours."),
    no_summary: bool = typer.Option(False, help="Disable AI summarization, just list."),
    credentials: str = typer.Option("credentials.json", help="Path to credentials file"),
    token: str = typer.Option("token.pickle", help="Path to saved token file.")
):
    """Fetch and summarize all announcements for each course."""
    console.print("üöÄ [bold]Initializing Google Classroom Summarizer...[/bold]")
    # --- MODIFIED ---
    monitor = ClassroomMonitor(console=console, credentials_file=credentials, token_file=token)
    print()

    # Determine which courses to process
    if course_id:
        try:
            with console.status(f"Fetching course info for {course_id}...", spinner="dots"):
                course_info = monitor.service.courses().get(id=course_id).execute()
            course_name = course_info.get('name', f'Course {course_id}')
        except HttpError:
            course_name = f'Course {course_id}'
        courses = [{'id': course_id, 'name': course_name}]
    elif all_courses:
        courses = monitor.get_courses()
        if not courses:
            console.print("[red]No active courses found.[/red]")
            raise typer.Exit()
    else:
        console.print("[yellow]‚ùó Please specify either --course-id or --all-courses.[/yellow]")
        raise typer.Exit()

    total = 0
    for course in courses:
        console.rule(f"[bold blue]üîç {course['name']} (ID: {course['id']})[/bold blue]")
        anns = monitor.get_announcements(course['id'], max_results=max_announcements, since_hours=since)
        
        if not anns:
            msg = "No announcements found"
            if since:
                msg += f" in the last {since} hours"
            console.print(f"[dim]{msg} in this course.[/dim]\n")
            continue

        total += len(anns)
        
        # --- NEW: Format announcement list better ---
        ann_list_text = Text()
        for i, ann in enumerate(anns, start=1):
            timestamp = monitor._parse_timestamp(ann.get('updateTime')).strftime("%Y-%m-%d %H:%M")
            text = ann.get('text', 'No content').strip().split('\n')[0] # Show first line
            ann_list_text.append(f"{i}. ", style="dim")
            ann_list_text.append(f"[{timestamp}] ", style="yellow")
            ann_list_text.append(f"{text[:100]}...\n")
            
        console.print(Panel(
            ann_list_text,
            title=f"üì¢ Found [green]{len(anns)}[/green] Announcement(s)",
            border_style="dim"
        ))
        # --- END NEW ---

        if not no_summary:
            summary = monitor.summarize_course_announcements(course['name'], anns)
            console.print(Panel(
                summary,
                title=f"[bold white]üìò COURSE SUMMARY: {course['name']}[/bold white]",
                border_style="blue",
                padding=(1, 2)
            ))
        print()

    console.rule("[bold]Summary Complete[/bold]")
    console.print(f"‚úÖ Processed [bold]{total}[/bold] announcements across [bold]{len(courses)}[/bold] course(s).\n")


# --- Commands from Detector Script ---
@app.command()
def detect(
    course_id: str = typer.Option(None, help="Specific course ID to scan."),
    all_courses: bool = typer.Option(False, "--all-courses", help="Scan all available courses."),
    max_announcements: int = typer.Option(20, "--max", help="Max announcements to scan per course."),
    since: int = typer.Option(None, help="Only scan announcements from last N hours."),
    keywords_only: bool = typer.Option(False, help="Only show detected keywords without generating ideas."),
    credentials: str = typer.Option("credentials.json", help="Path to credentials file"),
    token: str = typer.Option("token.pickle", help="Path to saved token file.")
):
    """
    Detect project/lab test announcements and generate tailored ideas/questions.
    """
    console.print("üöÄ [bold]Initializing Google Classroom Project Detector...[/bold]")
    # --- MODIFIED ---
    monitor = ClassroomMonitor(console=console, credentials_file=credentials, token_file=token)
    print()

    # Determine which courses to process
    if course_id:
        try:
            with console.status(f"Fetching course info for {course_id}...", spinner="dots"):
                course_info = monitor.service.courses().get(id=course_id).execute()
            course_name = course_info.get('name', f'Course {course_id}')
        except HttpError:
            course_name = f'Course {course_id}'
        courses = [{'id': course_id, 'name': course_name}]
    elif all_courses:
        courses = monitor.get_courses()
        if not courses:
            console.print("[red]No active courses found.[/red]")
            raise typer.Exit()
    else:
        console.print("[yellow]‚ùó Please specify either --course-id or --all-courses.[/yellow]")
        raise typer.Exit()

    total_announcements = 0
    total_projects_detected = 0
    total_lab_tests_detected = 0
    
    for course in courses:
        console.rule(f"[bold blue]üîç Scanning: {course['name']}[/bold blue]")
        anns = monitor.get_announcements(course['id'], max_results=max_announcements, since_hours=since)
        
        if not anns:
            msg = "No announcements found"
            if since:
                msg += f" in the last {since} hours"
            console.print(f"[dim]{msg} in this course.[/dim]\n")
            continue

        total_announcements += len(anns)
        console.print(f"üì¢ Scanning [green]{len(anns)}[/green] announcement(s) for keywords...\n")
        
        # Detect project announcements
        project_anns = monitor.detect_project_announcements(anns)
        
        # Detect lab test announcements
        lab_test_anns = monitor.detect_lab_test_announcements(anns)
        
        if not project_anns and not lab_test_anns:
            console.print("[dim]‚úó No project or lab test announcements detected in this course.[/dim]\n")
            continue
        
        # --- Process Project Announcements ---
        if project_anns:
            total_projects_detected += len(project_anns)
            console.print(f"üéØ [bold green]Found {len(project_anns)} project-related announcement(s)![/bold green]\n")
            
            for idx, (ann, keywords) in enumerate(project_anns, start=1):
                timestamp = monitor._parse_timestamp(ann.get('updateTime')).strftime("%Y-%m-%d %H:%M")
                text = ann.get('text', 'No content').strip()
                
                console.print(Panel(
                    f"[bold yellow]üìÖ Posted:[/bold yellow] {timestamp}\n\n"
                    f"[bold yellow]üîë Detected Keywords:[/bold yellow] {', '.join(keywords)}\n\n"
                    f"[bold yellow]üìù Full Announcement:[/bold yellow]\n{text}",
                    title=f"[bold cyan]Project Announcement #{idx} - {course['name']}[/bold cyan]",
                    border_style="cyan",
                    padding=(1, 2)
                ))
                
                if keywords_only:
                    console.print()
                    continue
                
                # --- MODIFIED --- (Spinner is inside the function)
                project_ideas = monitor.generate_tailored_project_ideas(
                    course['name'], 
                    text, 
                    keywords
                )
                
                console.print(Panel(
                    Markdown(project_ideas),
                    title=f"[bold green]üöÄ Tailored Project Ideas & Resources[/bold green]",
                    border_style="green",
                    padding=(1, 2)
                ))
                console.print("\n" + "="*80 + "\n")

        # --- Process Lab Test Announcements ---
        if lab_test_anns:
            total_lab_tests_detected += len(lab_test_anns)
            console.print(f"üß™ [bold yellow]Found {len(lab_test_anns)} lab test/evaluation announcement(s)![/bold yellow]\n")
            
            for idx, (ann, keywords) in enumerate(lab_test_anns, start=1):
                timestamp = monitor._parse_timestamp(ann.get('updateTime')).strftime("%Y-%m-%d %H:%M")
                text = ann.get('text', 'No content').strip()
                
                console.print(Panel(
                    f"[bold yellow]üìÖ Posted:[/bold yellow] {timestamp}\n\n"
                    f"[bold yellow]üîë Detected Keywords:[/bold yellow] {', '.join(keywords)}\n\n"
                    f"[bold yellow]üìù Full Announcement:[/bold yellow]\n{text}",
                    title=f"[bold magenta]Lab Test Announcement #{idx} - {course['name']}[/bold magenta]",
                    border_style="magenta",
                    padding=(1, 2)
                ))
                
                if keywords_only:
                    console.print()
                    continue
                    
                # --- MODIFIED --- (Spinner is inside the function)
                practice_questions = monitor.generate_practice_questions(
                    course['name'], 
                    text, 
                    keywords
                )
                
                console.print(Panel(
                    Markdown(practice_questions),
                    title=f"[bold blue]üìö Practice Questions & Study Guide[/bold blue]",
                    border_style="blue",
                    padding=(1, 2)
                ))
                console.print("\n" + "="*80 + "\n")

    # Summary
    console.rule("[bold]Detection Complete[/bold]")
    console.print(f"‚úÖ Scanned [bold]{total_announcements}[/bold] announcements across [bold]{len(courses)}[/bold] course(s)")
    console.print(f"üéØ Detected [bold green]{total_projects_detected}[/bold green] project-related announcements")
    console.print(f"üß™ Detected [bold yellow]{total_lab_tests_detected}[/bold yellow] lab test/evaluation announcements")
    
    if total_projects_detected == 0 and total_lab_tests_detected == 0:
        console.print("\n[yellow]üí° Tip: Try increasing the scan window with --since option or check more courses with --all-courses[/yellow]")
    
    console.print()


@app.command()
def analyze(
    announcement_text: str = typer.Argument(..., help="Project announcement text to analyze"),
    course_name: str = typer.Option("General", help="Course name for context"),
    credentials: str = typer.Option("credentials.json", help="Path to credentials file."),
    token: str = typer.Option("token.pickle", help="Path to saved token file.")
):
    """
    Analyze specific text and generate tailored project ideas OR practice questions.
    """
    console.print(f"üîç [bold]Analyzing announcement text for: {course_name}[/bold]\n")
    # --- MODIFIED ---
    # Authentication is needed just to set up the Gemini model
    monitor = ClassroomMonitor(console=console, credentials_file=credentials, token_file=token)
    
    # Detect project keywords
    project_keywords = []
    text_lower = announcement_text.lower()
    for keyword in PROJECT_KEYWORDS:
        if re.search(r'\b' + re.escape(keyword) + r'\b', text_lower, re.IGNORECASE):
            project_keywords.append(keyword)
    
    # Detect lab test keywords
    lab_test_keywords = []
    for keyword in LAB_TEST_KEYWORDS:
        if re.search(r'\b' + re.escape(keyword) + r'\b', text_lower, re.IGNORECASE):
            lab_test_keywords.append(keyword)

    if not project_keywords and not lab_test_keywords:
        console.print("[yellow]‚ö†Ô∏è No project or lab test keywords detected in the provided text.[/yellow]")
        console.print(f"[dim]Project keywords: {', '.join(PROJECT_KEYWORDS[:5])}...[/dim]")
        console.print(f"[dim]Lab Test keywords: {', '.join(LAB_TEST_KEYWORDS[:5])}...[/dim]\n")
        return

    # Prioritize Projects: If project keywords are present, run project analysis
    if project_keywords:
        console.print(Panel(
            f"[bold yellow]üîë Detected Project Keywords:[/bold yellow] {', '.join(project_keywords)}\n\n"
            f"[bold yellow]üìù Announcement Text:[/bold yellow]\n{announcement_text}",
            title=f"[bold cyan]Project Announcement Analysis[/bold cyan]",
            border_style="cyan",
            padding=(1, 2)
        ))
        
        # --- MODIFIED --- (Spinner is in the function)
        project_ideas = monitor.generate_tailored_project_ideas(
            course_name, 
            announcement_text, 
            project_keywords
        )
        
        console.print(Panel(
            Markdown(project_ideas),
            title=f"[bold green]üöÄ Tailored Project Ideas & Resources[/bold green]",
            border_style="green",
            padding=(1, 2)
        ))
    
    # Else If: If no project keywords, but lab test keywords are present, run lab test analysis
    elif lab_test_keywords:
        console.print(Panel(
            f"[bold yellow]üîë Detected Lab Test Keywords:[/bold yellow] {', '.join(lab_test_keywords)}\n\n"
            f"[bold yellow]üìù Announcement Text:[/bold yellow]\n{announcement_text}",
            title=f"[bold magenta]Lab Test Announcement Analysis[/bold magenta]",
            border_style="magenta",
            padding=(1, 2)
        ))
        
        # --- MODIFIED --- (Spinner is in the function)
        practice_questions = monitor.generate_practice_questions(
            course_name, 
            announcement_text, 
            lab_test_keywords
        )
        
        console.print(Panel(
            Markdown(practice_questions),
            title=f"[bold blue]üìö Practice Questions & Study Guide[/bold blue]",
            border_style="blue",
            padding=(1, 2)
        ))
        
    console.print()


# ---------------------- Main ----------------------
if __name__ == "__main__":
    app()
