import os
import io
import time
import json
import subprocess
import re
import click
import fitz  # PyMuPDF
import google.generativeai as genai
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaIoBaseDownload, MediaFileUpload
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import inch
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, CodeHighlighter
from reportlab.lib.styles import ParagraphStyle
from reportlab.lib.colors import HexColor

# --- CONFIGURATION ---------------------------------------------------

# 1. GOOGLE API: Scopes needed. This is crucial.
# We need Classroom, Drive (to read attachments), and Drive (to upload solutions)
SCOPES = [
    "https://www.googleapis.com/auth/classroom.announcements.readonly",
    "https://www.googleapis.com/auth/classroom.coursework.me",
    "https://www.googleapis.com/auth/classroom.student-submissions.me",
    "https://www.googleapis.com/auth/drive",
]

# 2. GEMINI AI: Configure your API key
# Get your key from https://aistudio.google.com/
# It's best to set this as an environment variable
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")

# --- WARNING ---------------------------------------------------------
# This script executes code generated by an AI. This is a
# MAJOR SECURITY RISK. The AI could generate malicious code
# (e.g., `rm -rf /`) that would run on your computer.
#
# DO NOT RUN THIS IN A PRODUCTION ENVIRONMENT.
# This is a proof-of-concept and should be run in a
# sandboxed environment (e.g., a Docker container).
# ---------------------------------------------------------------------

# --- 1. GOOGLE AUTHENTICATION ----------------------------------------

def authenticate():
    """Handles Google API authentication flow."""
    creds = None
    if os.path.exists("token.json"):
        creds = Credentials.from_authorized_user_file("token.json", SCOPES)
    
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            try:
                creds.refresh(Request())
            except Exception as e:
                click.secho(f"Token expired and refresh failed: {e}", fg="red")
                creds = None # Force re-login
        if not creds:
            if not os.path.exists("credentials.json"):
                click.secho("FATAL: 'credentials.json' not found.", fg="red")
                click.secho("Please download it from the Google Cloud Console.", fg="yellow")
                return None
            flow = InstalledAppFlow.from_client_secrets_file("credentials.json", SCOPES)
            creds = flow.run_local_server(port=0)
        
        with open("token.json", "w") as token:
            token.write(creds.to_json())
            
    return creds

# --- 2. AI CORE FUNCTIONS --------------------------------------------

def get_gemini_model():
    """Initializes and returns the Gemini model."""
    if not GEMINI_API_KEY:
        click.secho("FATAL: GEMINI_API_KEY environment variable not set.", fg="red")
        return None
    genai.configure(api_key=GEMINI_API_KEY)
    
    generation_config = {
      "temperature": 0.2,
      "top_p": 1,
      "top_k": 1,
      "max_output_tokens": 8192,
    }
    
    safety_settings = [
        {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
        {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
        {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
        {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
    ]

    return genai.GenerativeModel(
        model_name="gemini-1.0-pro",
        generation_config=generation_config,
        safety_settings=safety_settings
    )

def analyze_announcement_with_ai(model, text):
    """
    Sends announcement text to the AI for analysis, summarization,
    and recommendations. Returns a structured JSON.
    """
    if not model:
        return None

    prompt = f"""
    You are an expert classroom assistant. A teacher posted this announcement:
    ---
    {text}
    ---

    Analyze the text and provide a JSON response (do not wrap in markdown ```json```)
    with the following structure:
    {{
      "summary": "A concise, one-sentence summary of the announcement.",
      "type": "Identify the type: 'Test', 'Synopsis', 'Assignment', or 'Info'.",
      "recommendations": {{
        "videos": [
          "If type is 'Test' or 'Lab Evaluation', suggest 3-5 specific YouTube video search queries for the topics mentioned.",
          "If not 'Test', this can be an empty array."
        ],
        "practice_questions": [
          "If type is 'Test' or 'Lab Evaluation', generate 3 practice coding questions related to the topics.",
          "If not 'Test', this can be an empty array."
        ],
        "project_ideas": [
          "If type is 'Synopsis', generate 5 project ideas with a 1-sentence description each.",
          "If not 'Synopsis', this can be an empty array."
        ]
      }}
    }}

    Be precise and only return the JSON object.
    """
    
    try:
        response = model.generate_content(prompt)
        # Clean up Gemini's response to get raw JSON
        clean_response = re.sub(r"```json\n|\n```", "", response.text, flags=re.MULTILINE)
        return json.loads(clean_response)
    except Exception as e:
        click.secho(f"AI analysis failed: {e}", fg="red")
        click.secho(f"Raw response: {response.text}", fg="yellow")
        return None

def generate_solution_with_ai(model, pdf_text):
    """
    Sends assignment text to the AI to generate Java code solutions.
    Returns a structured JSON.
    """
    if not model:
        return None

    prompt = f"""
    You are an expert Java programmer. Here is the text from a PDF of a lab assignment:
    ---
    {pdf_text}
    ---

    Your task is to provide the complete, runnable Java code to solve all programs listed.
    Provide your response as a JSON object (do not wrap in markdown ```json```)
    in the following format:
    [
      {{
        "program_title": "Title of the first program (e.g., Program 1: DemoObject)",
        "filename": "The primary .java file (e.g., DemoObject.java)",
        "code": "The full Java source code for this file.",
        "main_class": "The class name to execute (e.g., DemoObject)"
      }},
      {{
        "program_title": "Program 2: Tracker",
        "filename": "Tracker.java",
        "code": "public class Tracker {{ ... }}",
        "main_class": "Tracker"
      }},
      {{
        "program_title": "Program 3: USB Pendrive",
        "filename": "devices/Pendrive.java",
        "code": "package devices; ... public class Pendrive implements USB {{ ... }}",
        "main_class": "devices.Pendrive"
      }},
      {{
        "program_title": "Program 3: USB Interface",
        "filename": "devices/USB.java",
        "code": "package devices; public interface USB {{ ... }}",
        "main_class": null
      }}
    ]

    Ensure all code is correct, complete, and follows Java best practices.
    Handle packages and multiple files correctly as shown in the example.
    Only return the JSON array.
    """
    
    try:
        response = model.generate_content(prompt)
        # Clean up Gemini's response to get raw JSON
        clean_response = re.sub(r"```json\n|\n```", "", response.text, flags=re.MULTILINE)
        return json.loads(clean_response)
    except Exception as e:
        click.secho(f"AI code generation failed: {e}", fg="red")
        click.secho(f"Raw response: {response.text}", fg="yellow")
        return None

# --- 3. CORE LOGIC: ASSIGNMENT HANDLER -------------------------------

def download_pdf_attachment(drive_service, file_id):
    """Downloads a PDF from Google Drive and returns its text."""
    try:
        request = drive_service.files().get_media(fileId=file_id)
        file_bytes = io.BytesIO()
        downloader = MediaIoBaseDownload(file_bytes, request)
        done = False
        while done is False:
            status, done = downloader.next_chunk()
        
        file_bytes.seek(0)
        
        # Read PDF text using PyMuPDF (fitz)
        text = ""
        with fitz.open(stream=file_bytes, filetype="pdf") as doc:
            for page in doc:
                text += page.get_text()
        return text
    except HttpError as e:
        click.secho(f"Failed to download attachment {file_id}: {e}", fg="red")
        return None
    except Exception as e:
        click.secho(f"Failed to read PDF {file_id}: {e}", fg="red")
        return None

def run_java_code(programs):
    """
    Compiles and runs the Java code, capturing output.
    Returns a list of results.
    """
    click.secho("--- WARNING: Executing AI-Generated Code ---", fg="red", bold=True)
    solution_data = []

    # Clean up previous runs
    os.system("rm -rf devices *.class *.java")

    try:
        # First, save all files
        for prog in programs:
            filename = prog['filename']
            code = prog['code']
            if "/" in filename:
                os.makedirs(os.path.dirname(filename), exist_ok=True)
            with open(filename, "w") as f:
                f.write(code)
            click.echo(f"  Saved {filename}")

        # Second, compile all files
        java_files = [p['filename'] for p in programs]
        compile_process = subprocess.run(
            ["javac"] + java_files,
            capture_output=True, text=True, timeout=15
        )
        
        if compile_process.returncode != 0:
            click.secho(f"Compilation Failed:\n{compile_process.stderr}", fg="red")
            return None
        
        click.secho("  All files compiled successfully.", fg="green")

        # Third, run runnable files and capture output
        for prog in programs:
            if prog['main_class']:
                click.echo(f"  Running {prog['main_class']}...")
                main_class = prog['main_class']
                
                # Handle package paths (e.g., devices.Pendrive)
                run_command = ["java", main_class.replace("/", ".")]

                run_process = subprocess.run(
                    run_command,
                    capture_output=True, text=True, timeout=10
                )
                
                output = run_process.stdout
                if run_process.stderr:
                    output += f"\nSTDERR:\n{run_process.stderr}"
                
                solution_data.append({
                    "title": prog['program_title'],
                    "code": prog['code'],
                    "output": output or "No console output."
                })
            else:
                # For non-runnable files like interfaces
                 solution_data.append({
                    "title": prog['program_title'],
                    "code": prog['code'],
                    "output": "Not a runnable main class (e.g., an interface)."
                })
        
        return solution_data

    except Exception as e:
        click.secho(f"Code execution failed: {e}", fg="red")
        return None
    finally:
        # Clean up
        os.system("rm -rf devices *.class *.java")
        click.echo("  Cleanup complete.")

def create_solution_pdf(pdf_name, solution_data):
    """Generates a PDF file with the code and output."""
    try:
        doc = SimpleDocTemplate(pdf_name, pagesize=A4)
        story = []
        styles = getSampleStyleSheet()
        
        # Style for code
        code_style = ParagraphStyle(
            'Code',
            parent=styles['Normal'],
            fontName='Courier',
            fontSize=8,
            leading=10,
            borderPadding=5,
            backgroundColor=HexColor("#F0F0F0"),
            leftIndent=6,
            rightIndent=6
        )
        
        # Style for output
        output_style = ParagraphStyle(
            'Output',
            parent=styles['Normal'],
            fontName='Courier',
            fontSize=8,
            leading=10,
            borderPadding=5,
            backgroundColor=HexColor("#E0E0FF"),
            leftIndent=6,
            rightIndent=6
        )
        
        for item in solution_data:
            story.append(Paragraph(item['title'], styles['h2']))
            story.append(Spacer(1, 0.1 * inch))
            
            story.append(Paragraph("Code:", styles['h3']))
            # Using Paragraph for code with line breaks
            code_text = item['code'].replace('\n', '<br/>').replace(' ', '&nbsp;')
            story.append(Paragraph(code_text, code_style))
            story.append(Spacer(1, 0.1 * inch))
            
            story.append(Paragraph("Output:", styles['h3']))
            output_text = item['output'].replace('\n', '<br/>').replace(' ', '&nbsp;')
            story.append(Paragraph(output_text, output_style))
            story.append(Spacer(1, 0.25 * inch))

        doc.build(story)
        click.secho(f"Solution PDF '{pdf_name}' created.", fg="green")
        return pdf_name
    except Exception as e:
        click.secho(f"Failed to create PDF: {e}", fg="red")
        return None

def upload_and_turn_in(classroom_service, drive_service, course_id, assignment, student_name, pdf_path):
    """Uploads the solution PDF to Drive and turns in the assignment."""
    try:
        assignment_id = assignment['id']
        assignment_title = assignment['title']
        
        # 1. Upload PDF to Google Drive
        click.echo(f"  Uploading '{pdf_path}' to Google Drive...")
        file_metadata = {'name': pdf_path}
        media = MediaFileUpload(pdf_path, mimetype='application/pdf')
        drive_file = drive_service.files().create(
            body=file_metadata,
            media_body=media,
            fields='id'
        ).execute()
        drive_file_id = drive_file.get('id')
        click.secho(f"  File uploaded to Drive. File ID: {drive_file_id}", fg="cyan")

        # 2. Attach Drive file to the submission
        click.echo(f"  Attaching Drive file to submission...")
        submission_id = 'me' # Special ID for the current user
        
        add_attachment_body = {
            "addAttachments": [
                {"driveFile": {"id": drive_file_id}}
            ]
        }
        
        classroom_service.courses().courseWork().studentSubmissions().modifyAttachments(
            courseId=course_id,
            courseWorkId=assignment_id,
            id=submission_id,
            body=add_attachment_body
        ).execute()
        click.secho(f"  File attached to assignment.", fg="cyan")

        # 3. Turn in the assignment
        click.echo(f"  Turning in assignment...")
        classroom_service.courses().courseWork().studentSubmissions().turnIn(
            courseId=course_id,
            courseWorkId=assignment_id,
            id=submission_id,
            body={}
        ).execute()
        
        click.secho(f"Successfully turned in assignment: '{assignment_title}'", fg="green", bold=True)
        return True

    except HttpError as e:
        click.secho(f"Failed to submit assignment: {e}", fg="red")
        return False
    except Exception as e:
        click.secho(f"An unexpected error occurred during submission: {e}", fg="red")
        return False

def handle_new_assignment(classroom_service, drive_service, model, assignment, student_name):
    """Orchestrates the entire assignment solving process."""
    click.secho(f"\n>>> New Assignment Found: {assignment['title']}", fg="magenta", bold=True)
    
    # 1. Find and read the PDF attachment
    pdf_text = None
    if 'materials' in assignment:
        for mat in assignment.get('materials', []):
            if 'driveFile' in mat:
                file_id = mat['driveFile']['driveFile']['id']
                file_name = mat['driveFile']['driveFile']['title']
                if file_name.lower().endswith('.pdf'):
                    click.echo(f"  Downloading assignment PDF: {file_name}")
                    pdf_text = download_pdf_attachment(drive_service, file_id)
                    if pdf_text:
                        click.secho("  PDF text extracted successfully.", fg="green")
                        break
    
    if not pdf_text:
        click.secho("  No PDF attachment found or PDF is unreadable. Skipping.", fg="yellow")
        return

    # 2. Send to AI for solution
    click.echo("  Sending assignment text to AI for solution...")
    programs = generate_solution_with_ai(model, pdf_text)
    if not programs:
        click.secho("  AI failed to generate a solution. Skipping.", fg="red")
        return
    click.secho("  AI solution generated successfully.", fg="green")
    
    # 3. Run the code
    solution_data = run_java_code(programs)
    if not solution_data:
        click.secho("  Failed to run generated code. Skipping.", fg="red")
        return
    click.secho("  AI code executed, output captured.", fg="green")

    # 4. Create solution PDF
    safe_title = re.sub(r'[^\w-]', '_', assignment['title'])
    pdf_name = f"{student_name}_{safe_title}.pdf"
    
    if not create_solution_pdf(pdf_name, solution_data):
        click.secho("  Failed to create solution PDF. Skipping.", fg="red")
        return

    # 5. Upload and Turn In
    if upload_and_turn_in(classroom_service, drive_service, assignment['courseId'], assignment, student_name, pdf_name):
        # Clean up local solution PDF
        os.remove(pdf_name)
    else:
        click.secho(f"  Failed to submit. Solution PDF '{pdf_name}' is saved locally.", fg="yellow")


# --- 4. CORE LOGIC: ANNOUNCEMENT HANDLER -----------------------------

def handle_new_announcement(model, announcement):
    """Analyzes and prints formatted output for an announcement."""
    click.secho(f"\n>>> New Announcement Found: (from {announcement['creatorUserId']})", fg="cyan", bold=True)
    click.echo(f"  {announcement['text']}")
    
    click.echo("  Analyzing announcement with AI...")
    ai_analysis = analyze_announcement_with_ai(model, announcement['text'])
    
    if not ai_analysis:
        click.secho("  AI analysis failed. Skipping.", fg="red")
        return

    click.echo("--- AI Analysis ---")
    click.secho(f"  Summary: {ai_analysis.get('summary')}", bold=True)
    click.secho(f"  Type: {ai_analysis.get('type')}")
    
    recs = ai_analysis.get('recommendations', {})
    
    if recs.get('videos'):
        click.secho("\n  Recommended Videos (Search Queries):", fg="yellow")
        for video in recs['videos']:
            click.echo(f"    - {video}")
            
    if recs.get('practice_questions'):
        click.secho("\n  AI-Generated Practice Questions:", fg="yellow")
        for i, q in enumerate(recs['practice_questions'], 1):
            click.echo(f"    {i}. {q}")
            
    if recs.get('project_ideas'):
        click.secho("\n  AI-Generated Project Ideas:", fg="yellow")
        for idea in recs['project_ideas']:
            click.echo(f"    - {idea}")
    click.echo("-------------------")


# --- 5. MAIN CLI COMMAND ---------------------------------------------

@click.command()
@click.option('--course-id', required=True, help='The ID of the Google Classroom course to monitor.')
@click.option('--name', required=True, help='Your full name (for naming the solution PDF). E.g., "JohnDoe"')
@click.option('--poll-interval', default=300, help='Time in seconds to wait between checks (e.g., 300 = 5 mins).')
def monitor(course_id, name, poll_interval):
    """
    Monitors a Google Classroom for new announcements and assignments.
    
    - Summarizes announcements and provides AI recommendations.
    - Automatically solves, executes, and submits PDF-based assignments.
    """
    
    click.secho("--- Classroom AI Agent ---", fg="green", bold=True)
    
    # --- DANGER WARNING ---
    click.secho("="*30 + " WARNING " + "="*30, fg="red", bold=True)
    click.secho("This script is configured to AUTOMATICALLY submit assignments.", fg="yellow")
    click.secho("This is a PROOF OF CONCEPT and likely violates academic integrity.", fg="yellow")
    click.secho("It also RUNS UNTRUSTED CODE from an AI on your machine.", fg="red")
    click.secho("You have 10 seconds to press CTRL+C to cancel.", fg="white")
    click.secho("="*70, fg="red", bold=True)
    
    try:
        time.sleep(10)
    except KeyboardInterrupt:
        click.secho("\nOperation cancelled by user.", fg="green")
        return

    click.secho("Initialization...", fg="green")
    creds = authenticate()
    if not creds:
        click.secho("Authentication failed. Exiting.", fg="red")
        return
        
    model = get_gemini_model()
    if not model:
        click.secho("Failed to initialize AI model. Exiting.", fg="red")
        return

    try:
        classroom_service = build("classroom", "v1", credentials=creds)
        drive_service = build("drive", "v3", credentials=creds)
        click.secho("Successfully connected to Google APIs.", fg="green")
    except Exception as e:
        click.secho(f"Failed to build Google API services: {e}", fg="red")
        return

    processed_announcements = set()
    processed_assignments = set()
    
    # Pre-load existing items to avoid processing old ones
    try:
        announcements = classroom_service.courses().announcements().list(courseId=course_id).execute()
        for a in announcements.get('announcements', []):
            processed_announcements.add(a['id'])
            
        assignments = classroom_service.courses().courseWork().list(courseId=course_id).execute()
        for a in assignments.get('courseWork', []):
            processed_assignments.add(a['id'])
        click.secho(f"Pre-loaded {len(processed_announcements)} announcements and {len(processed_assignments)} assignments.", fg="cyan")
    except HttpError as e:
        click.secho(f"Failed to pre-load course data: {e}", fg="red")
        return

    click.secho(f"--- Monitoring Course {course_id} ---", fg="green", bold=True)
    click.secho(f"Checking every {poll_interval} seconds. Press CTRL+C to stop.", fg="white")

    while True:
        try:
            # 1. Check for new announcements
            announcements = classroom_service.courses().announcements().list(courseId=course_id).execute()
            for a in announcements.get('announcements', []):
                if a['id'] not in processed_announcements:
                    handle_new_announcement(model, a)
                    processed_announcements.add(a['id'])

            # 2. Check for new assignments
            assignments = classroom_service.courses().courseWork().list(courseId=course_id).execute()
            for a in assignments.get('courseWork', []):
                if a['id'] not in processed_assignments:
                    # Check if it's a new assignment for the student
                    try:
                        sub = classroom_service.courses().courseWork().studentSubmissions().get(
                            courseId=course_id, courseWorkId=a['id'], id='me'
                        ).execute()
                        
                        # Only process if it's a new assignment (not turned in, etc.)
                        if sub['state'] in ['NEW', 'CREATED']:
                            handle_new_assignment(classroom_service, drive_service, model, a, name)
                        
                        processed_assignments.add(a['id'])
                        
                    except HttpError as e:
                        click.secho(f"Error checking submission state for {a['title']}: {e}", fg="yellow")
                        processed_assignments.add(a['id']) # Add to avoid re-checking
                        
            # Wait for the next poll
            time.sleep(poll_interval)

        except HttpError as e:
            click.secho(f"API Error: {e}", fg="red")
            click.secho("Waiting 60s before retrying...", fg="yellow")
            time.sleep(60)
        except KeyboardInterrupt:
            click.secho("\nStopping monitor. Goodbye!", fg="green")
            break
        except Exception as e:
            click.secho(f"An unexpected error occurred: {e}", fg="red")
            time.sleep(60)

if __name__ == "__main__":
    monitor()
