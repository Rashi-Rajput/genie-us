import os
import io
import time
import json
import subprocess
import re
import click
import fitz  # PyMuPDF
import google.generativeai as genai
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaIoBaseDownload, MediaFileUpload
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import inch
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, CodeHighlighter
from reportlab.lib.styles import ParagraphStyle
from reportlab.lib.colors import HexColor

# --- CONFIGURATION ---------------------------------------------------

# 1. GOOGLE API: Scopes needed. This is crucial.
# We need Classroom, Drive (to read attachments), and Drive (to upload solutions)
SCOPES = [
    "https://www.googleapis.com/auth/classroom.announcements.readonly",
    "https://www.googleapis.com/auth/classroom.coursework.me",
    "https://www.googleapis.com/auth/classroom.student-submissions.me",
    "https://www.googleapis.com/auth/drive",
]

# 2. GEMINI AI: Configure your API key
# Get your key from https://aistudio.google.com/
# It's best to set this as an environment variable
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")

# --- WARNING ---------------------------------------------------------
# This script executes code generated by an AI. This is a
# MAJOR SECURITY RISK. The AI could generate malicious code
# (e.g., `rm -rf /`) that would run on your computer.
#
# DO NOT RUN THIS IN A PRODUCTION ENVIRONMENT.
# This is a proof-of-concept and should be run in a
# sandboxed environment (e.g., a Docker container).
# ---------------------------------------------------------------------

# --- 1. GOOGLE AUTHENTICATION ----------------------------------------

def authenticate():
    """Handles Google API authentication flow."""
    creds = None
    if os.path.exists("token.json"):
        creds = Credentials.from_authorized_user_file("token.json", SCOPES)
    
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            try:
                creds.refresh(Request())
            except Exception as e:
                click.secho(f"Token expired and refresh failed: {e}", fg="red")
                creds = None # Force re-login
        if not creds:
            if not os.path.exists("credentials.json"):
                click.secho("FATAL: 'credentials.json' not found.", fg="red")
                click.secho("Please download it from the Google Cloud Console.", fg="yellow")
                return None
            flow = InstalledAppFlow.from_client_secrets_file("credentials.json", SCOPES)
            creds = flow.run_local_server(port=0)
        
        with open("token.json", "w") as token:
            token.write(creds.to_json())
            
    return creds

# --- 2. AI CORE FUNCTIONS --------------------------------------------

def get_gemini_model():
    """Initializes and returns the Gemini model."""
    if not GEMINI_API_KEY:
        click.secho("FATAL: GEMINI_API_KEY environment variable not set.", fg="red")
        return None
    genai.configure(api_key=GEMINI_API_KEY)
    
    generation_config = {
      "temperature": 0.2,
      "top_p": 1,
      "top_k": 1,
      "max_output_tokens": 8192,
    }
    
    safety_settings = [
        {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
        {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
        {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
        {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
    ]

    return genai.GenerativeModel(
        model_name="gemini-1.0-pro",
        generation_config=generation_config,
        safety_settings=safety_settings
    )

def analyze_announcement_with_ai(model, text):
    """
    Sends announcement text to the AI for analysis, summarization,
    and recommendations. Returns a structured JSON.
    """
    if not model:
        return None

    prompt = f"""
    You are an expert classroom assistant. A teacher posted this announcement:
    ---
    {text}
    ---

    Analyze the text and provide a JSON response (do not wrap in markdown ```json```)
    with the following structure:
    {{
      "summary": "A concise, one-sentence summary of the announcement.",
      "type": "Identify the type: 'Test', 'Synopsis', 'Assignment', or 'Info'.",
      "recommendations": {{
        "videos": [
          "If type is 'Test' or 'Lab Evaluation', suggest 3-5 specific YouTube video search queries for the topics mentioned.",
          "If not 'Test', this can be an empty array."
        ],
        "practice_questions": [
          "If type is 'Test' or 'Lab Evaluation', generate 3 practice coding questions related to the topics.",
          "If not 'Test', this can be an empty array."
        ],
        "project_ideas": [
          "If type is 'Synopsis', generate 5 project ideas with a 1-sentence description each.",
          "If not 'Synopsis', this can be an empty array."
        ]
      }}
    }}

    Be precise and only return the JSON object.
    """
    
    try:
        response = model.generate_content(prompt)
        # Clean up Gemini's response to get raw JSON
        clean_response = re.sub(r"```json\n|\n```", "", response.text, flags=re.MULTILINE)
        return json.loads(clean_response)
    except Exception as e:
        click.secho(f"AI analysis failed: {e}", fg="red")
        click.secho(f"Raw response: {response.text}", fg="yellow")
        return None

def generate_solution_with_ai(model, pdf_text):
    """
    Sends assignment text to the AI to generate Java code solutions.
    Returns a structured JSON.
    """
    if not model:
        return None

    prompt = f"""
    You are an expert Java programmer. Here is the text from a PDF of a lab assignment:
    ---
    {pdf_text}
    ---

    Your task is to provide the complete, runnable Java code to solve all programs listed.
    Provide your response as a JSON object (do not wrap in markdown ```json```)
    in the following format:
    [
      {{
        "program_title": "Title of the first program (e.g., Program 1: DemoObject)",
        "filename": "The primary .java file (e.g., DemoObject.java)",
        "code": "The full Java source code for this file.",
        "main_class": "The class name to execute (e.g., DemoObject)"
      }},
      {{
        "program_title": "Program 2: Tracker",
        "filename": "Tracker.java",
        "code": "public class Tracker {{ ... }}",
        "main_class": "Tracker"
      }},
      {{
        "program_title": "Program 3: USB Pendrive",
        "filename": "devices/Pendrive.java",
        "code": "package devices; ... public class Pendrive implements USB {{ ... }}",
        "main_class": "devices.Pendrive"
      }},
      {{
        "program_title": "Program 3: USB Interface",
        "filename": "devices/USB.java",
        "code": "package devices; public interface USB {{ ... }}",
        "main_class": null
      }}
    ]

    Ensure all code is correct, complete, and follows Java best practices.
    Handle packages and multiple files correctly as shown in the example.
    Only return the JSON array.
    """
    
    try:
        response = model.generate_content(prompt)
        # Clean up Gemini's response to get raw JSON
        clean_response = re.sub(r"```json\n|\n```", "", response.text, flags=re.MULTILINE)
        return json.loads(clean_response)
    except Exception as e:
        click.secho(f"AI code generation failed: {e}", fg="red")
        click.secho(f"Raw response: {response.text}", fg="yellow")
        return None

# --- 3. CORE LOGIC: ASSIGNMENT HANDLER -------------------------------

def download_pdf_attachment(drive_service, file_id):
    """Downloads a PDF from Google Drive and returns its text."""
    try:
        request = drive_service.files().get_media(fileId=file_id)
        file_bytes = io.BytesIO()
        downloader = MediaIoBaseDownload(file_bytes, request)
        done = False
        while done is False:
            status, done = downloader.next_chunk()
        
        file_bytes.seek(0)
        
        # Read PDF text using PyMuPDF (fitz)
        text = ""
        with fitz.open(stream=file_bytes, filetype="pdf") as doc:
            for page in doc:
                text += page.get_text()
        return text
    except HttpError as e:
        click.secho(f"Failed to download attachment {file_id}: {e}", fg="red")
        return None
    except Exception as e:
        click.secho(f"Failed to read PDF {file_id}: {e}", fg="red")
        return None

def run_java_code(programs):
    """
    Compiles and runs the Java code, capturing output.
    Returns a list of results.
    """
    click.secho("--- WARNING: Executing AI-Generated Code ---", fg="red", bold=True)
    solution_data = []

    # Clean up previous runs
    os.system("rm -rf devices *.class *.java")

    try:
        # First, save all files
        for prog in programs:
            filename = prog['filename']
            code = prog['code']
            if "/" in filename:
                os.makedirs(os.path.dirname(filename), exist_ok=True)
            with open(filename, "w") as f:
                f.write(code)
            click.echo(f"  Saved {filename}")

        # Second, compile all files
        java_files = [p['filename'] for p in programs]
        compile_process = subprocess.run(
            ["javac"] + java_files,
            capture_output=True, text=True, timeout=15
        )
        
        if compile_process.returncode != 0:
            click.secho(f"Compilation Failed:\n{compile_process.stderr}", fg="red")
            return None
        
        click.secho("  All files compiled successfully.", fg="green")

        # Third, run runnable files and capture output
        for prog in programs:
            if prog['main_class']:
                click.echo(f"  Running {prog['main_class']}...")
                main_class = prog['main_class']
                
                # Handle package paths (e.g., devices.Pendrive)
                run_command = ["java", main_class.replace("/", ".")]

                run_process = subprocess.run(
                    run_command,
                    capture_output=True, text=True, timeout=10
                )
                
                output = run_process.stdout
                if run_process.stderr:
                    output += f"\nSTDERR:\n{run_process.stderr}"
                
                solution_data.append({
                    "title": prog['program_title'],
                    "code": prog['code'],
                    "output": output or "No console output."
                })
            else:
                # For non-runnable files like interfaces
                 solution_data.append({
                    "title": prog['program_title'],
                    "code": prog['code'],
                    "output": "Not a runnable main class (e.g., an interface)."
                })
        
        return solution_data

    except Exception as e:
        click.secho(f"Code execution failed: {e}", fg="red")
        return None
    finally:
        # Clean up
        os.system("rm -rf devices *.class *.java")
        click.echo("  Cleanup complete.")

def create_solution_pdf(pdf_name, solution_data):
    """Generates a PDF file with the code and output."""
    try:
        doc = SimpleDocTemplate(pdf_name, pagesize=A4)
        story = []
        styles = getSampleStyleSheet()
        
        # Style for code
        code_style = ParagraphStyle(
            'Code',
            parent=styles['Normal'],
            fontName='Courier',
            fontSize=8,
            leading=10,
            borderPadding=5,
            backgroundColor=HexColor("#F0F0F0"),
            leftIndent=6,
            rightIndent=6
        )
        
        # Style for output
        output_style = ParagraphStyle(
            'Output',
            parent=styles['Normal'],
            fontName='Courier',
            fontSize=8,
            leading=10,
            borderPadding=5,
            backgroundColor=HexColor("#E0E0FF"),
            leftIndent=6,
            rightIndent=6
        )
        
        for item in solution_data:
            story.append(Paragraph(item['title'], styles['h2']))
            story.append(Spacer(1, 0.1 * inch))
            
            story.append(Paragraph("Code:", styles['h3']))
            # Using Paragraph for code with line breaks
            code_text = item['code'].replace('\n', '<br/>').replace(' ', '&nbsp;')
            story.append(Paragraph(code_text, code_style))
            story.append(Spacer(1, 0.1 * inch))
            
            story.append(Paragraph("Output:", styles['h3']))
            output_text = item['output'].replace('\n', '<br/>').replace(' ', '&nbsp;')
            story.append(Paragraph(output_text, output_style))
            story.append(Spacer(1, 0.25 * inch))

        doc.build(story)
        click.secho(f"Solution PDF '{pdf_name}' created.", fg="green")
        return pdf_name
    except Exception as e:
        click.secho(f"Failed to create PDF: {e}", fg="red")
        return None

def upload_and_turn_in(classroom_service, drive_service, course_id, assignment, student_name, pdf_path):
    """Uploads the solution PDF to Drive and turns in the assignment."""
    try:
        assignment_id = assignment['id']
        assignment_title = assignment['title']
        
        # 1. Upload PDF to Google Drive
        click.echo(f"  Uploading '{pdf_path}' to Google Drive...")
        file_metadata = {'name': pdf_path}
        media = MediaFileUpload(pdf_path, mimetype='application/pdf')
        drive_file = drive_service.files().create(
            body=file_metadata,
            media_body=media,
            fields='id'
        ).execute()
        drive_file_id = drive_file.get('id')
        click.secho(f"  File uploaded to Drive. File ID: {drive_file_id}", fg="cyan")

        # 2. Attach Drive file to the submission
        click.echo(f"  Attaching Drive file to submission...")
        submission_id = 'me' # Special ID for the current user
        
        add_attachment_body = {
            "addAttachments": [
                {"driveFile": {"id": drive_file_id}}
            ]
        }
        
        classroom_service.courses().courseWork().studentSubmissions().modifyAttachments(
            courseId=course_id,
            courseWorkId=assignment_id,
            id=submission_id,
            body=add_attachment_body
        ).execute()
        click.secho(f"  File attached to assignment.", fg="cyan")

        # 3. Turn in the assignment
        click.echo(f"  Turning in assignment...")
        classroom_service.courses().courseWork().studentSubmissions().turnIn(
            courseId=course_id,
            courseWorkId=assignment_id,
            id=submission_id,
            body={}
        ).execute()
        
        click.secho(f"Successfully turned in assignment: '{assignment_title}'", fg="green", bold=True)
        return True

    except HttpError as e:
        click.secho(f"Failed to submit assignment: {e}", fg="red")
        return False
    except Exception as e:
        click.secho(f"An unexpected error occurred during submission: {e}", fg="red")
        return False

def handle_new_assignment(classroom_service, drive_service, model, assignment, student_name):
    """Orchestrates the entire assignment solving process."""
    click.secho(f"\n>>> New Assignment Found: {assignment['title']}", fg="magenta", bold=True)
    
    # 1. Find and read the PDF attachment
    pdf_text = None
    if 'materials' in assignment:
        for mat in assignment.get('materials', []):
            if 'driveFile' in mat:
                file_id = mat['driveFile']['driveFile']['id']
                file_name = mat['driveFile']['driveFile']['title']
                if file_name.lower().endswith('.pdf'):
                    click.echo(f"  Downloading assignment PDF: {file_name}")
                    pdf_text = download_pdf_attachment(drive_service, file_id)
                    if pdf_text:
                        click.secho("  PDF text extracted successfully.", fg="green")
                        break
    
    if not pdf_text:
        click.secho("  No PDF attachment found or PDF is unreadable. Skipping.", fg="yellow")
        return

    # 2. Send to AI for solution
    click.echo("  Sending assignment text to AI for solution...")
    programs = generate_solution_with_ai(model, pdf_text)
    if not programs:
        click.secho("  AI failed to generate a solution. Skipping.", fg="red")
        return
    click.secho("  AI solution generated successfully.", fg="green")
    
    # 3. Run the code
    solution_data = run_java_code(programs)
    if not solution_data:
        click.secho("  Failed to run generated code. Skipping.", fg="red")
        return
    click.secho("  AI code executed, output captured.", fg="green")

    # 4. Create solution PDF
    safe_title = re.sub(r'[^\w-]', '_', assignment['title'])
    pdf_name = f"{student_name}_{safe_title}.pdf"
    
    if not create_solution_pdf(pdf_name, solution_data):
        click.secho("  Failed to create solution PDF. Skipping.", fg="red")
        return

    # 5. Upload and Turn In
    if upload_and_turn_in(classroom_service, drive_service, assignment['courseId'], assignment, student_name, pdf_name):
        # Clean up local solution PDF
        os.remove(pdf_name)
    else:
        click.secho(f"  Failed to submit. Solution PDF '{pdf_name}' is saved locally.", fg="yellow")


# --- 4. CORE LOGIC: ANNOUNCEMENT HANDLER -----------------------------

def handle_new_announcement(model, announcement):
    """Analyzes and prints formatted output for an announcement."""
    click.secho(f"\n>>> New Announcement Found: (from {announcement['creatorUserId']})", fg="cyan", bold=True)
    click.echo(f"  {announcement['text']}")
    
    click.echo("  Analyzing announcement with AI...")
    ai_analysis = analyze_announcement_with_ai(model, announcement['text'])
    
    if not ai_analysis:
        click.secho("  AI analysis failed. Skipping.", fg="red")
        return

    click.echo("--- AI Analysis ---")
    click.secho(f"  Summary: {ai_analysis.get('summary')}", bold=True)
    click.secho(f"  Type: {ai_analysis.get('type')}")
    
    recs = ai_analysis.get('recommendations', {})
    
    if recs.get('videos'):
        click.secho("\n  Recommended Videos (Search Queries):", fg="yellow")
        for video in recs['videos']:
            click.echo(f"    - {video}")
            
    if recs.get('practice_questions'):
        click.secho("\n  AI-Generated Practice Questions:", fg="yellow")
        for i, q in enumerate(recs['practice_questions'], 1):
            click.echo(f"    {i}. {q}")
            
    if recs.get('project_ideas'):
        click.secho("\n  AI-Generated Project Ideas:", fg="yellow")
        for idea in recs['project_ideas']:
            click.echo(f"    - {idea}")
    click.echo("-------------------")


# --- 5. MAIN CLI COMMAND ---------------------------------------------

@click.command()
@click.option('--course-id', required=True, help='The ID of the Google Classroom course to monitor.')
@click.option('--name', required=True, help='Your full name (for naming the solution PDF). E.g., "JohnDoe"')
@click.option('--poll-interval', default=300, help='Time in seconds to wait between checks (e.g., 300 = 5 mins).')
def monitor(course_id, name, poll_interval):
    """
    Monitors a Google Classroom for new announcements and assignments.
    
    - Summarizes announcements and provides AI recommendations.
    - Automatically solves, executes, and submits PDF-based assignments.
    """
    
    click.secho("--- Classroom AI Agent ---", fg="green", bold=True)
    
    # --- DANGER WARNING ---
    click.secho("="*30 + " WARNING " + "="*30, fg="red", bold=True)
    click.secho("This script is configured to AUTOMATICALLY submit assignments.", fg="yellow")
    click.secho("This is a PROOF OF CONCEPT and likely violates academic integrity.", fg="yellow")
    click.secho("It also RUNS UNTRUSTED CODE from an AI on your machine.", fg="red")
    click.secho("You have 10 seconds to press CTRL+C to cancel.", fg="white")
    click.secho("="*70, fg="red", bold=True)
    
    try:
        time.sleep(10)
    except KeyboardInterrupt:
        click.secho("\nOperation cancelled by user.", fg="green")
        return

    click.secho("Initialization...", fg="green")
    creds = authenticate()
    if not creds:
        click.secho("Authentication failed. Exiting.", fg="red")
        return
        
    model = get_gemini_model()
    if not model:
        click.secho("Failed to initialize AI model. Exiting.", fg="red")
        return

    try:
        classroom_service = build("classroom", "v1", credentials=creds)
        drive_service = build("drive", "v3", credentials=creds)
        click.secho("Successfully connected to Google APIs.", fg="green")
    except Exception as e:
        click.secho(f"Failed to build Google API services: {e}", fg="red")
        return

    processed_announcements = set()
    processed_assignments = set()
    
    # Pre-load existing items to avoid processing old ones
    try:
        announcements = classroom_service.courses().announcements().list(courseId=course_id).execute()
        for a in announcements.get('announcements', []):
            processed_announcements.add(a['id'])
            
        assignments = classroom_service.courses().courseWork().list(courseId=course_id).execute()
        for a in assignments.get('courseWork', []):
            processed_assignments.add(a['id'])
        click.secho(f"Pre-loaded {len(processed_announcements)} announcements and {len(processed_assignments)} assignments.", fg="cyan")
    except HttpError as e:
        click.secho(f"Failed to pre-load course data: {e}", fg="red")
        return

    click.secho(f"--- Monitoring Course {course_id} ---", fg="green", bold=True)
    click.secho(f"Checking every {poll_interval} seconds. Press CTRL+C to stop.", fg="white")

    while True:
        try:
            # 1. Check for new announcements
            announcements = classroom_service.courses().announcements().list(courseId=course_id).execute()
            for a in announcements.get('announcements', []):
                if a['id'] not in processed_announcements:
                    handle_new_announcement(model, a)
                    processed_announcements.add(a['id'])

            # 2. Check for new assignments
            assignments = classroom_service.courses().courseWork().list(courseId=course_id).execute()
            for a in assignments.get('courseWork', []):
                if a['id'] not in processed_assignments:
                    # Check if it's a new assignment for the student
                    try:
                        sub = classroom_service.courses().courseWork().studentSubmissions().get(
                            courseId=course_id, courseWorkId=a['id'], id='me'
                        ).execute()
                        
                        # Only process if it's a new assignment (not turned in, etc.)
                        if sub['state'] in ['NEW', 'CREATED']:
                            handle_new_assignment(classroom_service, drive_service, model, a, name)
                        
                        processed_assignments.add(a['id'])
                        
                    except HttpError as e:
                        click.secho(f"Error checking submission state for {a['title']}: {e}", fg="yellow")
                        processed_assignments.add(a['id']) # Add to avoid re-checking
                        
            # Wait for the next poll
            time.sleep(poll_interval)#!/usr/bin/env python3
"""
Google Classroom Automation CLI
- Lists classes (courses) and assignments
- Fetches assignment PDF, extracts text
- Uses OpenAI to generate Java solutions per question
- Compiles and runs Java; captures outputs
- Builds a PDF solution doc with title page
- Uploads to Drive, attaches to Classroom submission, and turns in

Author: You
"""

import argparse
import os
import sys
import re
import io
import json
import time
import shutil
import logging
import tempfile
import subprocess
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any, Tuple

# Google APIs
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaIoBaseDownload, MediaFileUpload

# PDF text extraction
from pdfminer.high_level import extract_text

# OCR fallback (optional)
try:
    import pytesseract
    from pdf2image import convert_from_path
    OCR_AVAILABLE = True
except Exception:
    OCR_AVAILABLE = False

# PDF generation
from reportlab.lib.pagesizes import LETTER
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak, Preformatted

# OpenAI for code generation
try:
    from openai import OpenAI
    OPENAI_AVAILABLE = True
except Exception:
    OPENAI_AVAILABLE = False

logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")

# Google API scopes
SCOPES = [
    "https://www.googleapis.com/auth/classroom.courses.readonly",
    "https://www.googleapis.com/auth/classroom.coursework.me",
    "https://www.googleapis.com/auth/classroom.courseworkmaterials.readonly",
    "https://www.googleapis.com/auth/classroom.student-submissions.me",
    "https://www.googleapis.com/auth/classroom.student-submissions.me.readonly",
    "https://www.googleapis.com/auth/drive.readonly",
    "https://www.googleapis.com/auth/drive.file"
]

DEFAULT_STUDENT_NAME = "Rashi"

@dataclass
class QuestionSolution:
    index: int
    question_text: str
    class_name: str
    java_code: str
    run_args: List[str] = field(default_factory=list)
    output: str = ""
    compile_ok: bool = False
    run_ok: bool = False
    compile_err: str = ""
    run_err: str = ""


def get_credentials() -> Credentials:
    creds = None
    token_path = "token.json"
    client_secret_path = os.environ.get("GOOGLE_CLIENT_SECRET", "client_secret.json")
    if os.path.exists(token_path):
        creds = Credentials.from_authorized_user_file(token_path, SCOPES)
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            try:
                from google.auth.transport.requests import Request
                creds.refresh(Request())
            except Exception:
                creds = None
        if not creds:
            if not os.path.exists(client_secret_path):
                raise FileNotFoundError("Missing OAuth client secrets at client_secret.json. "
                                        "Download from Google Cloud Console and save as client_secret.json")
            flow = InstalledAppFlow.from_client_secrets_file(client_secret_path, SCOPES)
            creds = flow.run_local_server(port=0)
        with open(token_path, "w") as token:
            token.write(creds.to_json())
    return creds


def classroom_service(creds: Credentials):
    return build("classroom", "v1", credentials=creds)


def drive_service(creds: Credentials):
    return build("drive", "v3", credentials=creds)


def list_courses_cmd(args):
    creds = get_credentials()
    service = classroom_service(creds)
    courses = []
    page_token = None
    while True:
        resp = service.courses().list(pageSize=100, pageToken=page_token).execute()
        courses.extend(resp.get("courses", []))
        page_token = resp.get("nextPageToken")
        if not page_token:
            break

    if not courses:
        print("No classes found.")
        return

    print("Classes (Courses):")
    print("-" * 80)
    for c in courses:
        cid = c.get("id")
        name = c.get("name")
        section = c.get("section", "")
        state = c.get("courseState", "")
        print(f"ID: {cid} | Name: {name} | Section: {section} | State: {state}")


def list_assignments_cmd(args):
    creds = get_credentials()
    service = classroom_service(creds)
    course_id = args.course_id
    try:
        course = service.courses().get(id=course_id).execute()
        print(f"Class: {course.get('name')} (ID: {course_id})")
    except HttpError as e:
        logging.error(f"Error fetching course: {e}")
        sys.exit(1)

    cw_service = service.courses().courseWork()
    courseworks = []
    page_token = None
    while True:
        resp = cw_service.list(courseId=course_id, pageSize=100, pageToken=page_token).execute()
        courseworks.extend(resp.get("courseWork", []))
        page_token = resp.get("nextPageToken")
        if not page_token:
            break

    if not courseworks:
        print("No assignments found for this class.")
        return

    print("Assignments:")
    print("-" * 80)
    for cw in courseworks:
        cid = cw.get("id")
        title = cw.get("title")
        state = cw.get("state", "")
        due = cw.get("dueDate", {})
        due_time = cw.get("dueTime", {})
        due_str = ""
        if due:
            due_str = f"{due.get('year','')}-{str(due.get('month','')).zfill(2)}-{str(due.get('day','')).zfill(2)}"
            if due_time:
                due_str += f" {str(due_time.get('hours','0')).zfill(2)}:{str(due_time.get('minutes','0')).zfill(2)}"
        print(f"ID: {cid} | Title: {title} | State: {state} | Due: {due_str}")
        # Show materials briefly
        mats = cw.get("materials", [])
        if mats:
            mat_summ = []
            for m in mats:
                if "driveFile" in m:
                    mat_summ.append(f"DriveFile: {m['driveFile']['driveFile'].get('title','(no title)')}")
                elif "link" in m:
                    mat_summ.append(f"Link: {m['link'].get('title','')}")
                elif "youtubeVideo" in m:
                    mat_summ.append("YouTube")
            if mat_summ:
                print("  Materials:", "; ".join(mat_summ))


def download_assignment_pdfs(service_classroom, service_drive, course_id: str, coursework_id: str, dest_dir: str) -> List[str]:
    """Download PDF materials for the coursework. Returns list of local file paths."""
    cw = service_classroom.courses().courseWork().get(courseId=course_id, id=coursework_id).execute()
    materials = cw.get("materials", [])
    pdf_paths = []
    os.makedirs(dest_dir, exist_ok=True)
    for m in materials:
        if "driveFile" in m:
            df = m["driveFile"]["driveFile"]
            file_id = df["id"]
            # Inspect mimeType
            meta = service_drive.files().get(fileId=file_id, fields="id,name,mimeType").execute()
            name = meta["name"]
            mime = meta.get("mimeType")
            if mime == "application/pdf" or name.lower().endswith(".pdf"):
                out_path = os.path.join(dest_dir, name)
                request = service_drive.files().get_media(fileId=file_id)
                fh = io.FileIO(out_path, "wb")
                downloader = MediaIoBaseDownload(fh, request)
                done = False
                while not done:
                    status, done = downloader.next_chunk()
                fh.close()
                logging.info(f"Downloaded: {out_path}")
                pdf_paths.append(out_path)
    return pdf_paths


def extract_text_from_pdf(pdf_path: str) -> str:
    try:
        text = extract_text(pdf_path)
        if text and len(text.strip()) >= 50:
            return text
    except Exception as e:
        logging.warning(f"pdfminer failed, trying OCR if available. Error: {e}")

    if not OCR_AVAILABLE:
        logging.warning("OCR not available; install pytesseract and pdf2image for scanned PDFs.")
        return ""

    # OCR fallback
    try:
        images = convert_from_path(pdf_path, dpi=300)
        ocr_texts = []
        for img in images:
            ocr_texts.append(pytesseract.image_to_string(img))
        return "\n".join(ocr_texts)
    except Exception as e:
        logging.error(f"OCR failed: {e}")
        return ""


def sanitize_class_name(name: str) -> str:
    name = re.sub(r"[^A-Za-z0-9_]", "_", name)
    if not re.match(r"[A-Za-z_]", name):
        name = f"Q_{name}"
    return name


def check_java_installed() -> Tuple[bool, str]:
    try:
        out = subprocess.run(["javac", "-version"], capture_output=True, text=True)
        if out.returncode == 0 or out.stderr.startswith("javac"):
            # Java prints version to stderr often
            ver_line = out.stderr.strip() or out.stdout.strip()
            return True, ver_line
        return False, out.stderr or out.stdout
    except FileNotFoundError:
        return False, "javac not found on PATH"


def compile_and_run_java(class_name: str, java_code: str, work_dir: str, run_args: Optional[List[str]] = None) -> Tuple[bool, bool, str, str]:
    """Compile and run a Java class. Returns (compile_ok, run_ok, stdout, stderr)."""
    run_args = run_args or []
    java_file = os.path.join(work_dir, f"{class_name}.java")
    with open(java_file, "w", encoding="utf-8") as f:
        f.write(java_code)

    # Compile
    comp = subprocess.run(["javac", "-encoding", "UTF-8", java_file], capture_output=True, text=True, cwd=work_dir)
    if comp.returncode != 0:
        return False, False, "", comp.stderr

    # Run
    run = subprocess.run(["java", class_name] + run_args, capture_output=True, text=True, cwd=work_dir, timeout=20)
    run_ok = (run.returncode == 0)
    return True, run_ok, run.stdout, run.stderr


def build_solution_pdf(output_path: str, course_name: str, assignment_name: str, student_name: str, solutions: List[QuestionSolution]):
    # Prepare document
    doc = SimpleDocTemplate(output_path, pagesize=LETTER, rightMargin=54, leftMargin=54, topMargin=54, bottomMargin=54)
    styles = getSampleStyleSheet()
    style_title = styles["Title"]
    style_h1 = styles["Heading1"]
    style_h2 = styles["Heading2"]
    style_body = styles["BodyText"]
    style_mono = ParagraphStyle(
        name="Monospace",
        parent=styles["Code"],
        fontName="Courier",
        fontSize=9,
        leading=12,
    )

    story = []

    # Title page
    story.append(Spacer(1, 2 * inch))
    story.append(Paragraph(assignment_name, style_title))
    story.append(Spacer(1, 0.3 * inch))
    story.append(Paragraph(f"Course: {course_name}", style_h2))
    story.append(Paragraph(f"Student: {student_name}", style_h2))
    story.append(Spacer(1, 4 * inch))
    story.append(Paragraph("Generated by Google Classroom CLI", style_body))
    story.append(PageBreak())

    # Questions
    for sol in solutions:
        story.append(Paragraph(f"Q{sol.index}. Original Question Text", style_h1))
        story.append(Spacer(1, 0.1 * inch))
        story.append(Paragraph(escape_html(sol.question_text).replace("\n", "<br/>"), style_body))
        story.append(Spacer(1, 0.2 * inch))

        story.append(Paragraph("âœ… Java Code Solution (fully working)", style_h2))
        story.append(Spacer(1, 0.1 * inch))
        story.append(Preformatted(sol.java_code, style_mono))
        story.append(Spacer(1, 0.2 * inch))

        story.append(Paragraph("ðŸ“¸ Output Screenshot / Output Block", style_h2))
        story.append(Spacer(1, 0.1 * inch))
        output_block = sol.output if (sol.compile_ok and sol.run_ok) else (
            "Compilation or execution failed.\n"
            f"Compile OK: {sol.compile_ok}\n"
            f"Run OK: {sol.run_ok}\n"
            f"Compile Errors:\n{sol.compile_err}\n"
            f"Runtime Errors:\n{sol.run_err}\n"
        )
        story.append(Preformatted(output_block, style_mono))
        story.append(PageBreak())

    doc.build(story)
    logging.info(f"Solution PDF created: {output_path}")


def escape_html(s: str) -> str:
    return s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")


def sanitize_filename(name: str) -> str:
    name = re.sub(r"[^\w\-. ]", "_", name)
    name = name.strip().replace(" ", "_")
    return name[:120]


def upload_to_drive(drive, file_path: str, mime_type: str = "application/pdf") -> Dict[str, Any]:
    file_metadata = {
        "name": os.path.basename(file_path),
        "mimeType": mime_type,
    }
    media = MediaFileUpload(file_path, mimetype=mime_type, resumable=True)
    f = drive.files().create(body=file_metadata, media_body=media, fields="id,webViewLink").execute()
    logging.info(f"Uploaded to Drive: {f['id']}")
    return f


def get_my_submission(classroom, course_id: str, coursework_id: str) -> Optional[Dict[str, Any]]:
    # Many API versions accept userId='me' parameter
    try:
        resp = classroom.courses().courseWork().studentSubmissions().list(
            courseId=course_id, courseWorkId=coursework_id, pageSize=10, userId="me"
        ).execute()
    except TypeError:
        # Fallback if userId not supported: fetch and find first with "userId" equal to me (not trivial without profile)
        resp = classroom.courses().courseWork().studentSubmissions().list(
            courseId=course_id, courseWorkId=coursework_id, pageSize=100
        ).execute()
    subs = resp.get("studentSubmissions", [])
    if not subs:
        return None
    # Return the first submission for this user
    # Some courses allow multiple submissions; take the first in "state" NEW|CREATED|RECLAIMED_BY_STUDENT
    for s in subs:
        if s.get("state") in ("CREATED", "NEW", "RECLAIMED_BY_STUDENT", "RETURNED"):
            return s
    return subs[0]


def attach_and_turn_in(classroom, course_id: str, coursework_id: str, submission_id: str, drive_file_id: str):
    # Attach drive file
    try:
        req_body = {
            "addAttachments": [
                {"driveFile": {"id": drive_file_id}}
            ]
        }
        classroom.courses().courseWork().studentSubmissions().modifyAttachments(
            courseId=course_id, courseWorkId=coursework_id, id=submission_id, body=req_body
        ).execute()
        logging.info("Attached PDF to submission.")
    except HttpError as e:
        logging.error(f"Failed to attach file: {e}")

    # Turn in (if not already turned in)
    try:
        classroom.courses().courseWork().studentSubmissions().turnIn(
            courseId=course_id, courseWorkId=coursework_id, id=submission_id, body={}
        ).execute()
        logging.info("Submission turned in.")
    except HttpError as e:
        if "already turned in" in str(e).lower():
            logging.info("Submission already turned in.")
        else:
            logging.error(f"Turn in failed: {e}")


def generate_solutions_with_openai(assignment_text: str, course_name: str, assignment_name: str, student_name: str) -> List[QuestionSolution]:
    if not OPENAI_AVAILABLE:
        raise RuntimeError("OpenAI library not installed. pip install openai")
    api_key = os.environ.get("OPENAI_API_KEY")
    if not api_key:
        raise RuntimeError("OPENAI_API_KEY environment variable is not set.")
    client = OpenAI(api_key=api_key)

    system = (
        "You are a senior Java instructor. Extract all programming questions from the provided assignment text. "
        "For each question:\n"
        "- Provide the original question text (verbatim).\n"
        "- Provide a fully working Java program with a public class and a main method.\n"
        "- Do NOT use packages.\n"
        "- Ensure the program does not require interactive input; if the prompt requires input, pick reasonable sample inputs embedded in code so it runs headlessly and demonstrates the solution.\n"
        "- Use class names: Q1_Solution, Q2_Solution, etc.\n"
        "- The code must compile with Java 17.\n"
        "Return a strict JSON object of the form:\n"
        "{\n"
        '  "questions": [\n'
        '    {\n'
        '      "index": 1,\n'
        '      "question_text": "<original text>",\n'
        '      "class_name": "Q1_Solution",\n'
        '      "java_code": "public class Q1_Solution { ... }",\n'
        '      "run_args": []\n'
        "    }, ...\n"
        "  ]\n"
        "}\n"
    )

    user = f"Course: {course_name}\nAssignment: {assignment_name}\nAssignment PDF text follows:\n---\n{assignment_text}\n---\n"

    resp = client.chat.completions.create(
        model="gpt-4o-mini",
        temperature=0.2,
        messages=[
            {"role": "system", "content": system},
            {"role": "user", "content": user}
        ]
    )

    content = resp.choices[0].message.content
    # Try to extract JSON if surrounded by code fences
    json_text = content
    fence_match = re.search(r"```json\s*(.*?)```", content, re.S)
    if fence_match:
        json_text = fence_match.group(1).strip()
    else:
        # Try any fence
        fence_match = re.search(r"```(.*?)```", content, re.S)
        if fence_match:
            json_text = fence_match.group(1).strip()

    data = json.loads(json_text)
    out: List[QuestionSolution] = []
    for q in data.get("questions", []):
        idx = int(q.get("index", len(out) + 1))
        class_name = sanitize_class_name(q.get("class_name", f"Q{idx}_Solution"))
        code = q.get("java_code", "")
        # Ensure class name matches file class
        class_decl_match = re.search(r"public\s+class\s+([A-Za-z_]\w*)", code)
        if class_decl_match and class_decl_match.group(1) != class_name:
            # Rename class in code to expected class_name
            code = re.sub(r"(public\s+class\s+)([A-Za-z_]\w*)", r"\1" + class_name, code, count=1)

        out.append(QuestionSolution(
            index=idx,
            question_text=q.get("question_text", "").strip(),
            class_name=class_name,
            java_code=code.strip(),
            run_args=q.get("run_args", []) or []
        ))
    return out


def solve_and_submit_cmd(args):
    student_name = args.student_name or DEFAULT_STUDENT_NAME
    creds = get_credentials()
    classroom = classroom_service(creds)
    drive = drive_service(creds)

    course_id = args.course_id
    coursework_id = args.coursework_id

    # Fetch course and assignment meta
    course = classroom.courses().get(id=course_id).execute()
    cw = classroom.courses().courseWork().get(courseId=course_id, id=coursework_id).execute()
    course_name = course.get("name", f"Course_{course_id}")
    assignment_name = cw.get("title", f"Assignment_{coursework_id}")

    # Download or use provided PDF
    tmp_dir = tempfile.mkdtemp(prefix="gc_cli_")
    try:
        if args.pdf:
            pdf_paths = [args.pdf]
        else:
            pdf_paths = download_assignment_pdfs(classroom, drive, course_id, coursework_id, tmp_dir)

        if not pdf_paths:
            logging.error("No PDF materials found for this assignment. Provide --pdf to supply a local file.")
            sys.exit(1)

        pdf_path = pdf_paths[0]
        logging.info(f"Processing PDF: {pdf_path}")

        # Extract text
        text = extract_text_from_pdf(pdf_path)
        if not text or len(text.strip()) < 10:
            logging.error("Failed to extract text from the PDF.")
            sys.exit(1)

        # Check Java
        ok, ver = check_java_installed()
        if not ok:
            logging.error(f"Java compiler not available: {ver}")
            sys.exit(1)
        logging.info(f"Java detected: {ver}")

        # Generate solutions via OpenAI
        solutions = generate_solutions_with_openai(text, course_name, assignment_name, student_name)

        # Compile & run each
        build_dir = os.path.join(tmp_dir, "java_build")
        os.makedirs(build_dir, exist_ok=True)
        for sol in sorted(solutions, key=lambda s: s.index):
            comp_ok, run_ok, out_str, err_str = compile_and_run_java(sol.class_name, sol.java_code, build_dir, sol.run_args)
            sol.compile_ok = comp_ok
            sol.run_ok = run_ok
            sol.output = out_str
            sol.compile_err = "" if comp_ok else err_str
            sol.run_err = "" if run_ok else err_str
            logging.info(f"Q{sol.index} compile: {comp_ok}, run: {run_ok}")

        # Build PDF
        pdf_name = f"Rashi_{sanitize_filename(assignment_name)}.pdf"
        output_pdf = os.path.abspath(pdf_name)
        build_solution_pdf(output_pdf, course_name, assignment_name, student_name, solutions)

        # Upload to Drive
        uploaded = upload_to_drive(drive, output_pdf, mime_type="application/pdf")

        # Attach & turn in
        submission = get_my_submission(classroom, course_id, coursework_id)
        if not submission:
            logging.error("Could not find your student submission for this assignment.")
            sys.exit(1)

        attach_and_turn_in(classroom, course_id, coursework_id, submission["id"], uploaded["id"])
        print(f"Done. Submitted: {output_pdf} (Drive file ID: {uploaded['id']})")

    finally:
        if not args.keep_temp:
            shutil.rmtree(tmp_dir, ignore_errors=True)


def process_local_pdf_cmd(args):
    student_name = args.student_name or DEFAULT_STUDENT_NAME
    course_name = args.course_name or "Unknown Course"
    assignment_name = args.assignment_name or "Assignment"
    pdf_path = args.pdf

    if not os.path.exists(pdf_path):
        logging.error(f"PDF not found: {pdf_path}")
        sys.exit(1)

    text = extract_text_from_pdf(pdf_path)
    if not text or len(text.strip()) < 10:
        logging.error("Failed to extract text from the PDF.")
        sys.exit(1)

    ok, ver = check_java_installed()
    if not ok:
        logging.error(f"Java compiler not available: {ver}")
        sys.exit(1)
    logging.info(f"Java detected: {ver}")

    solutions = generate_solutions_with_openai(text, course_name, assignment_name, student_name)

    tmp_dir = tempfile.mkdtemp(prefix="gc_cli_local_")
    try:
        build_dir = os.path.join(tmp_dir, "java_build")
        os.makedirs(build_dir, exist_ok=True)
        for sol in sorted(solutions, key=lambda s: s.index):
            comp_ok, run_ok, out_str, err_str = compile_and_run_java(sol.class_name, sol.java_code, build_dir, sol.run_args)
            sol.compile_ok = comp_ok
            sol.run_ok = run_ok
            sol.output = out_str
            sol.compile_err = "" if comp_ok else err_str
            sol.run_err = "" if run_ok else err_str

        pdf_name = f"Rashi_{sanitize_filename(assignment_name)}.pdf"
        output_pdf = os.path.abspath(pdf_name)
        build_solution_pdf(output_pdf, course_name, assignment_name, student_name, solutions)
        print(f"Built solution PDF: {output_pdf}")
    finally:
        if not args.keep_temp:
            shutil.rmtree(tmp_dir, ignore_errors=True)


def main():
    parser = argparse.ArgumentParser(description="Google Classroom Automation CLI")
    sub = parser.add_subparsers(required=True)

    # list-courses
    p1 = sub.add_parser("list-courses", help="List all classes and their IDs")
    p1.set_defaults(func=list_courses_cmd)

    # list-assignments
    p2 = sub.add_parser("list-assignments", help="List assignments and IDs for a class")
    p2.add_argument("--course-id", required=True, help="Course (class) ID")
    p2.set_defaults(func=list_assignments_cmd)

    # solve-and-submit
    p3 = sub.add_parser("solve-and-submit", help="Fetch assignment PDF, solve, generate PDF, and submit")
    p3.add_argument("--course-id", required=True, help="Course ID")
    p3.add_argument("--coursework-id", required=True, help="Assignment (courseWork) ID")
    p3.add_argument("--student-name", default=DEFAULT_STUDENT_NAME, help="Student name for title page")
    p3.add_argument("--pdf", help="Path to local assignment PDF (override download)")
    p3.add_argument("--keep-temp", action="store_true", help="Keep temp working directory for debugging")
    p3.set_defaults(func=solve_and_submit_cmd)

    # process-local-pdf (no submission)
    p4 = sub.add_parser("process-pdf", help="Process a local PDF, generate solutions PDF (no submission)")
    p4.add_argument("--pdf", required=True, help="Path to local assignment PDF")
    p4.add_argument("--course-name", help="Course name (for title page)")
    p4.add_argument("--assignment-name", help="Assignment name (for title page and filename)")
    p4.add_argument("--student-name", default=DEFAULT_STUDENT_NAME, help="Student name for title page")
    p4.add_argument("--keep-temp", action="store_true", help="Keep temp working directory for debugging")
    p4.set_defaults(func=process_local_pdf_cmd)

    args = parser.parse_args()
    try:
        args.func(args)
    except HttpError as e:
        logging.error(f"Google API error: {e}")
        sys.exit(1)
    except KeyboardInterrupt:
        print("\nAborted by user.")
        sys.exit(1)


if __name__ == "__main__":
    main()

        except HttpError as e:
            click.secho(f"API Error: {e}", fg="red")
            click.secho("Waiting 60s before retrying...", fg="yellow")
            time.sleep(60)
        except KeyboardInterrupt:
            click.secho("\nStopping monitor. Goodbye!", fg="green")
            break
        except Exception as e:
            click.secho(f"An unexpected error occurred: {e}", fg="red")
            time.sleep(60)

if __name__ == "__main__":
    monitor()
